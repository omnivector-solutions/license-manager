{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>An Omnivector initiative</p> <p></p>"},{"location":"#welcome-to-the-license-manager-documentation","title":"Welcome to the License Manager documentation!","text":"<p>The License Manager is a license scheduling middleware that operates as an interface between an HPC cluster and one or more 3rd party license servers. </p> <p>It introduces the concept of \"license bookings\" which are used to provide an alternate source of truth for what licenses are actually available.</p> <p>It\u2019s responsible for keeping the Slurm license counters in sync with the actual usage from the license servers and preventing jobs from requesting licenses already booked for another job.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>To run License Manager you will need three different systems:</p> <ol> <li>Slurm cluster (where <code>License Manager Agent</code> runs)</li> <li>License servers (FlexLM, RLM, LS-Dyna, LM-X, OLicense, DSLS or License Manager Simulator)</li> <li>API with license information (<code>License Manager API</code>)</li> </ol>"},{"location":"getting_started/#slurm-cluster","title":"Slurm cluster","text":"<p>License Manager is designed to work with Slurm. To learn how to create a Slurm cluster, please refer to the Omnivector Slurm Distribution documentation.</p>"},{"location":"getting_started/#license-servers","title":"License servers","text":"<p>License Manager supports the following license servers:</p> <ul> <li>FlexLM</li> <li>RLM</li> <li>LS-Dyna</li> <li>LM-X</li> <li>OLicense</li> <li>DSLS</li> </ul> <p>You need to have the license server installed and working on a path that is accessible to the <code>License Manager Agent</code>. The path for each license server binary is configurable in the <code>License Manager Agent</code> charm. In case you don't have a license server, you can use the <code>License Manager Simulator</code> to simulate the output of a license server.</p>"},{"location":"getting_started/#license-manager-api","title":"License Manager API","text":"<p>The <code>License Manager API</code> is an API that stores license usage information gathered from the license servers by the agent's reconciliation process. This data is used to update the license counters in the cluster to reflect the actual usage of the licenses. For each license tracked by License Manager, you need to create a configuration in the API. This includes the license name, the license features, the license server type and location, and the grace time (how long it takes for the license to be checked out after the job starts).</p> <p>To learn how to set up each system needed, please refer to the Development section.</p>"},{"location":"architecture/","title":"License Manager Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>License Manager works in a client/server architecture, where the main components are the Agent, the API and the CLI.</p> <p>The License Manager Agent is the component that syncs the local Slurm license counters with the License Server data. It's also responsible for making Booking requests to the License Manager API when a job is submitted to Slurm.</p> <p>The License Manager API provides a RESTful API where license usage and Bookings are tracked. The License Manager Agent uses this API to store the license usage information and to process the Booking requests.</p> <p>The License Manager CLI provides an interface for managing license Configurations and retrieving usage information for tracked licenses via the License Manager API. </p>"},{"location":"architecture/#architecture","title":"Architecture","text":"<p>Each component has its own architecture page:</p> <ul> <li> <p>License Manager Agent</p> </li> <li> <p>License Manager API</p> </li> <li> <p>LIcense Manager CLI</p> </li> </ul>"},{"location":"architecture/agent/","title":"License Manager Agent","text":"<p>The License Manager Agent is the key component that ensures jobs have enough free licenses to execute successfully. Deployed on the Slurm cluster, this agent works in conjunction with the License Manager API to track license usage and prevent job failures due to insufficient licenses.  </p> <p>The agent has two main functionalities:</p> <ul> <li> <p>Sync the local Slurm license counters with the usage from the License Server</p> </li> <li> <p>Manage the license requests from jobs submitted to the cluster using Bookings</p> </li> </ul> <p>Since the Slurm license counter doesn't directly interact with License Servers, the License Manager Agent actively polls the servers for data. Then it updates the corresponding counters in Slurm. Each cluster managed by License Manager has a dedicated license counter linked to the License Server. This configuration allows for license sharing across multiple clusters.</p>"},{"location":"architecture/agent/#bookings","title":"Bookings","text":"<p>License Manager provides custom scripts for SlurmctldProlog and SlurmctldEpilog that are executed when a job is submitted and when it finishes.</p> <p>When submitting a job to Slurm, if the sbatch directive for requesting licenses (<code>-L</code> or <code>--licenses</code>) is included in the job script, the SlurmctldProlog will intercept the job and make a Booking request to the License Manager API. The Booking reserves the needed licenses prior to the allocation of the job. The Booking ensures that the licenses are available for the job to use by taking into consideration the licenses booked for other jobs and the license usage in the License Server.</p> <p>If the Booking cannot be made, the job will be kept in the queue until there are enough licenses available to satisfy the Booking request.</p> <p>To calculate if the license is available for use, the formula used is:</p> \\[ \\begin{aligned} \\text{available} &amp;= \\text{licenses booked} \\\\ &amp;+ \\text{licenses used in License Server} \\\\ &amp;+ \\text{licenses requested by job} \\\\ &amp;&lt; \\text{total amount of licenses} \\end{aligned} \\] <p>The Booking will live until one of the following conditions are met:</p> <ul> <li>When the Grace Time expires:</li> </ul> <p>The Grace Time defaults to 5 minutes, but it can be configured by setting an environment variable in the Agent's configuration file. Grace time expiration is checked by the Reconcilliation process.</p> <ul> <li>When License Manager identifies that the license was already checked out:</li> </ul> <p>The license is checked-out when the application is granted the licenses by the License Server. The Reconcilliation process checks for matches between the active Bookings and the licenses checked out in the License Server to check if the Booking can be deleted.</p> <ul> <li>When the job finishes running:</li> </ul> <p>The SlurmctldEpilog script is executed when a job finishes. This script will delete the booking if the License Manager API is still tracking the booking, which happens when the job finishes before the expiration of the Grace Time.</p>"},{"location":"architecture/agent/#deleting-bookings-by-grace-time","title":"Deleting Bookings by Grace Time","text":"<p>Depending on the HPC application used by a job, it may take some time to check out the license from the License Server after it is submitted to Slurm. It will take longer for jobs that have multiple setup steps before actually starting the application that requires the license.</p> <p>Thus, each license has a Grace Time period that is used to indicate how long a Booking will be retained.</p> <p>After the Grace Time expires, the Booking is deleted. This means that the license was checked out from the License Server and doesn't need a Booking anymore.</p> <p>If the Booking is not deleted once the license is checked out, License Manager would account for usage twice: once for the Booking and once for the actual usage. This double booking issue is mitigated by the Grace Time and by matching the Booking with the usage from the License Server.</p>"},{"location":"architecture/agent/#deleting-bookings-by-matching","title":"Deleting Bookings by matching","text":"<p>License Manager parses output from each License Server to gather information into two main sections:  </p> <ul> <li> <p>License information: Used and Total counters</p> </li> <li> <p>Usage: how many licenses each User is using and the Lead Host from where the request was made</p> </li> </ul> <p>The Booking from License Manager contains the same information as the usage section.</p> <p>If there\u2019s a match between a Booking and a usage line from the License Server, the Booking is deleted even if the Grace Time is not expired yet. This prevents double booking the license, since License Manager would take into account the Booking and the usage when updating the total amount of licenses used.</p>"},{"location":"architecture/agent/#reconciliation","title":"Reconciliation","text":"<p>For each license tracked by License Manager, the License Manager Agent will periodically poll the License Servers to get the usage information and store it in the License Manager API. This process is called Reconciliation. The stat-interval is the period of time between each Reconciliation and can be configured in the License Manager Agent configuration file.</p> <p>The Reconciliation is also triggered when the SlurmctldProlog and SlurmctldEpilog run.</p> <p>The information in the License Manager API is used by the Reconciliation process to update the license counters in Slurm.</p>"},{"location":"architecture/agent/#slurm-license-counters","title":"Slurm License Counters","text":"<p>The license counter in Slurm shows the total number of licenses, how many are in use, and how many are reserved. The counter for licenses-in-use only accounts for licenses being used by jobs running in the cluster and can\u2019t be edited manually.</p> <p>The licenses can be used anywhere, such as other clusters and desktop applications sharing the same license pool, so the Reconciliation syncs the counters in the cluster with the values in the License Servers to account for usage in other environments.</p> <p>The main issue is that the Used counter is a read-only value, which prevents License Manager from updating the counter directly. If this was possible, it would be easier to update the Used counter to reflect the actual usage in the License Server. But since it's not possible, License Manager uses the Reservation to achieve the same result.</p>"},{"location":"architecture/agent/#slurm-reservation","title":"Slurm Reservation","text":"<p>Slurm has the ability to reserve resources to be used by specific users. This can also be used to block resource usage during maintenance downtime, for example.</p> <p>Due to the Slurm counters being immutable, License Manager Agent uses this feature to block the licenses that are already in use in the License Server, which can be used in any environment. </p> <p>The Reservation mechanism should not be confused with the Booking created by the SlurmctldProlog in the License Manager API.</p> <ul> <li>Reservation: Represents the licenses in use in the License Server that are not being used by the cluster.</li> <li>Booking: Represents the licenses that are reserved for a job in the cluster.</li> </ul> <p>To calculate the number of licenses reserved, the following formula is used:</p> \\[ \\begin{aligned} \\text{reserved} &amp;= \\text{licenses used in License Server} \\\\ &amp;- \\text{licenses used by Slurm} \\\\ &amp;+ \\text{licenses booked} \\end{aligned} \\] <p>This Reservation is not meant to be consumed by users nor jobs; it's only a representation of the licenses in use.</p> <p>The Reservation is created by the user configured in the License Manager Agent configuration file. The user must have a user account in the Slurm cluster and have operator privilege level to manage Reservations.</p>"},{"location":"architecture/agent/#license-manager-agent-workflow","title":"License Manager Agent Workflow","text":"<p>Sequence diagram for the timed Reconciliation:</p> <pre><code>    sequenceDiagram\n        participant Slurm\n        participant Reconciliation\n        participant LicenseServer as License Server\n        participant LMAPI as LM API\n\n        %% Sequence begins\n        Slurm-&gt;&gt;Reconciliation: Timed Reconciliation\n        Reconciliation-&gt;&gt;LicenseServer: Access License Server\n        LicenseServer--&gt;&gt;Reconciliation: Get updated counters\n        Reconciliation-&gt;&gt;LMAPI: Update API counters\n        Reconciliation-&gt;&gt;LMAPI: Clean Bookings by grace time and matching\n        LMAPI--&gt;&gt;Reconciliation: Get new counters with Bookings deleted\n        Reconciliation--&gt;&gt;Slurm: Update Reservation with license usage</code></pre> <p>Sequence diagram for when a job is submitted to Slurm: <pre><code>    sequenceDiagram\n        participant Slurm\n        participant Prolog\n        participant Reconciliation\n        participant LicenseServer as License Server\n        participant LMAPI as LM API\n\n        %% Sequence begins\n        Slurm-&gt;&gt;Prolog: Job is submitted\n        Prolog-&gt;&gt;Reconciliation: Forced Reconciliation\n        Reconciliation-&gt;&gt;LicenseServer: Access License Server\n        LicenseServer--&gt;&gt;Reconciliation: Get updated counters\n        Reconciliation-&gt;&gt;LMAPI: Update API counters\n        Reconciliation-&gt;&gt;Slurm: Update Reservation with license usage\n        Prolog-&gt;&gt;LMAPI: Create Booking\n        LMAPI--&gt;&gt;Prolog: Booking creation succeeded\n        Slurm-&gt;&gt;Slurm: Start job\n\n        %% Timed Reconciliation starts\n        Slurm-&gt;&gt;Reconciliation: Timed Reconciliation\n        Reconciliation-&gt;&gt;LicenseServer: Access License Server\n        LicenseServer--&gt;&gt;Reconciliation: Get updated counters\n        Reconciliation-&gt;&gt;LMAPI: Clean Bookings by grace time and matching\n        LMAPI--&gt;&gt;Reconciliation: Keep Booking (not expired or not checked out yet)\n        Reconciliation-&gt;&gt;Slurm: Update Reservation with license usage\n\n        %% Job checks out the license\n        Slurm-&gt;&gt;LicenseServer: Job checks out the license\n        Slurm-&gt;&gt;Reconciliation: Timed Reconciliation\n        Reconciliation-&gt;&gt;LicenseServer: Access License Server\n        LicenseServer--&gt;&gt;Reconciliation: Get updated counters\n        Reconciliation-&gt;&gt;LMAPI: Clean Bookings by grace time and matching\n        LMAPI--&gt;&gt;Reconciliation: Delete Booking (matched with a checked-out license)\n        Reconciliation-&gt;&gt;Slurm: Update Reservation with license usage</code></pre></p>"},{"location":"architecture/agent/#reference","title":"Reference","text":"<p>The reference page contains the parsers, server interfaces, services and backend communication modules available.</p>"},{"location":"architecture/api/","title":"License Manager API","text":"<p>The License Manager API provides a RESTful API where licenses and bookings are tracked. The License Manager Agent uses this API to store the license usage information and to process the Booking requests. The License Manager CLI interacts with this API to add new configurations and to check the usage information for each tracked license.</p> <p>The License Manager API is also responsible for verifying if the Booking requests can be satisfied by accounting for Bookings already made and the license usage in the License Server.</p> <p>The License Manager API contains 6 distinct resources with interconnecting relationships. This means that some of the resources need to be created before others can be created as well.</p> <pre><code>    erDiagram\n        Bookings {\n            int id pk\n            int job_id pk\n            int feature_id pk\n            int quantity\n        }\n        Features {\n            int id pk,fk\n            str name\n            int config_id pk\n            int product_id pk\n            int reserved\n            int total\n            int used\n            int booked_total\n        }\n        Products {\n            int id pk\n            str name\n        }\n        Jobs {\n            int id pk, fk\n            str slurm_job_id\n            str cluster_client_id\n            str username\n            str lead_host\n        }\n        Configurations {\n            int id pk\n            str name\n            str cluster_client_id\n            int grace_time\n            enum[str] type\n        }\n        LicenseServers {\n            int id pk\n            int config_id fk\n            str host\n            int port\n        }\n        Jobs ||--o{ Bookings : \"\"\n        Features ||--o{ Bookings : \"\"\n        Products ||--o{ Features : \"\"\n        Configurations ||--|{ Features : \"\"\n        Configurations ||--|{ LicenseServers : \"\"</code></pre>"},{"location":"architecture/api/#configurations","title":"Configurations","text":"<p>The Configuration resource holds the information for a set of Features that are available on the same License Server.</p> <p>A Configuration represents the license configured in the Slurm cluster. The configuration is linked to the cluster by the cluster_client_id field.</p> <p>The License Manager Agent instance running in the cluster will only reconcile the licenses configured for that cluster.</p> <p>Since each License Server can have multiple licenses configured, the same Configuration can be used for each license present in the License Server. The same command will be used to check the license usage for all the licenses under the same configuration.</p> <p>The Configuration also defines the license type, the License Server host addresses and the Grace Time period.</p> <p>The license type identifies the provider of the License Server.</p> <p>The following License Server types are supported:</p> <ul> <li>FlexLM</li> <li>RLM</li> <li>LS-Dyna</li> <li>LM-X</li> <li>OLicense</li> <li>DSLS</li> </ul>"},{"location":"architecture/api/#license-servers","title":"License Servers","text":"<p>The License Server resource represents the actual License Server where the license is installed.</p> <p>A License Server has a host and a port, and each Configuration must have at least one License Server related to it. The Configuration can cave multiple License Servers for redundancy, as long as they provide the same data. Each License Server will be called, in order, if the previous one is not available.</p>"},{"location":"architecture/api/#products","title":"Products","text":"<p>The Product resource represents the product name of the license.</p> <p>Each license is identified in the cluster as <code>product.feature@license_server_type</code>. The Product is used to group the licenses that are under the same License Server</p> <p>To create a Feature, a Product needs to be created first.</p>"},{"location":"architecture/api/#features","title":"Features","text":"<p>The Feature resource represents the licenses in the cluster.</p> <p>Each Feature must be related to a Configuration and a Product.</p> <p>The reserved value represents how many licenses should be reserved for usage in desktop applications. The amount of licenses reserved is not used by the cluster.</p> <p>License Manager Agent polls the License Server to populate the used and total values. The information stored includes the total number of licenses available, how many licenses are in use in the License Server and how many are booked.</p> <p>The <code>/lm/features/by_client_id</code> endpoint extracts the cluster_client_id from the request and updates the feature for that cluster. This endpoint is needed since there can be multiple licenses with the same name in different clusters.</p> <p>The <code>/lm/features/bulk</code> endpoint is used by the License Manager Agent to update the counters for multiple features with the same request.</p>"},{"location":"architecture/api/#jobs","title":"Jobs","text":"<p>The Job resource represents the jobs submitted to the cluster.</p> <p>When a job is submitted to Slurm, it is intercepted by the SlurmctldProlog script, which creates a Job in the License Manager API.</p> <p>Each Job can have multiple Bookings related to it, depending on the number of licenses requested by the job.</p> <p>Once the job finishes, the SlurmctldEpilog deletes the job from the License Manager API , along with its Bookings.</p> <p>Since the  <code>slurm_job_id</code> is not unique across clusters, each job is identified by the <code>cluster_client_id</code> alongside the <code>slurm_job_id</code>.</p> <p>The endpoint <code>/lm/jobs/by_client_id</code> extracts the <code>cluster_client_id</code> from the request and returns the jobs that belong to the cluster.</p> <p>The in the POST endpoint, the parameter <code>cluster_client_id</code> is optional. If it's not provided, the <code>cluster_client_id</code> is extracted from the request.</p>"},{"location":"architecture/api/#bookings","title":"Bookings","text":"<p>The Booking resource is responsible for Booking licenses for a specific job.</p> <p>The Booking ensures the job will have enough licenses to be used when it requests them to the License Server.</p> <p>Each Booking is related to a Job. The <code>job_id</code> parameter identifies the Job in the License Manager API, and is different from the <code>slurm_job_id</code> that idenfies it in the cluster.</p>"},{"location":"architecture/api/#permissions","title":"Permissions","text":"<p>The License Manager API needs an authentication provider (OIDC) to work safely.</p> <p>To manage permissions, the License Manager API uses the Armasec library. Armasec documentation has getting started guides to configure Keycloak or Auth0 as the OIDC provider.</p> <p>The endpoints have granular permissions, and the user needs to have the correct set of permissions to access them. Each endpoint has four permissions, for example:</p> <ul> <li><code>license-manager:config:create</code></li> <li><code>license-manager:config:read</code></li> <li><code>license-manager:config:update</code></li> <li><code>license-manager:config:delete</code></li> </ul> <p>There's also the <code>license-manager:admin</code> permission, which allows access to all operations in all endpoints.</p>"},{"location":"architecture/api/#reference","title":"Reference","text":"<p>The reference page contains the endpoints and schemas available.</p>"},{"location":"architecture/cli/","title":"License Manager CLI","text":""},{"location":"architecture/cli/#license-manager-cli","title":"License Manager CLI","text":"<p>The License Manager CLI is a client to interact with the License Manager API.</p> <p>It can be used to add new configurations to the API and to check the usage information for each tracked license.</p> <p>The Jobs and Bookings are read only. The remaining resources can be edited by users with permission to do so.</p>"},{"location":"architecture/cli/#global-commands","title":"Global commands","text":"Command Description lm-cli login Generate a URL for logging in via browser lm-cli show-token Print your access token (created after logging in) lm-cli logout Logout and remove your access token"},{"location":"architecture/cli/#configuration-commands","title":"Configuration commands","text":"Command Description lm-cli configurations list List all configurations lm-cli configurations list--search &lt;search string&gt; Search configurations with the specified string lm-cli configurations list--sort-field &lt;sort field&gt; Sort configurations by the specified field lm-cli configurations list--sort-field &lt;sort field&gt;--sort-order &lt;ascending or descending&gt; Sort configurations by the specified order lm-cli configurations get-one--id &lt;configuration id&gt; List the configuration with the specified id lm-cli configurations create--name &lt;configuration name&gt;--cluster-client-id &lt;OIDC client_id of the cluster where the configuration applies&gt;--grace-time &lt;grace time in seconds&gt;--license-server-type &lt;License Server type&gt; Create a new configuration lm-cli configurations delete--id &lt;id to delete&gt; Delete the configuration with the specified id"},{"location":"architecture/cli/#license-server-commands","title":"License server commands","text":"Command Description lm-cli license-servers list List all License Servers lm-cli license-servers list--search &lt;search string&gt; Search License Servers with the specified string lm-cli license-servers list--sort-field &lt;sort field&gt; Sort License Servers by the specified field lm-cli license-servers list--sort-field &lt;sort field&gt;--sort-order &lt;ascending or descending&gt; Sort License Servers by the specified order lm-cli license-servers get-one--id &lt;License Server id&gt; List the License Server with the specified id lm-cli license-servers create--config-id &lt;id of the configuration to add the License Server&gt;--host &lt;hostname of the License Server&gt;--port &lt;port of the License Server&gt; Create a new License Server lm-cli license-servers delete--id &lt;id to delete&gt; Delete the License Server with the specified id"},{"location":"architecture/cli/#product-commands","title":"Product commands","text":"Command Description lm-cli products list List all products lm-cli products list--search &lt;search string&gt; Search products with the specified string lm-cli products list--sort-field &lt;sort field&gt; Sort products by the specified field lm-cli products list--sort-field &lt;sort field&gt;--sort-order &lt;ascending or descending&gt; Sort products by the specified order lm-cli products get-one--id &lt;product id&gt; List the product with the specified id lm-cli products create--name &lt;product name&gt; Create a new product lm-cli products delete--id &lt;id to delete&gt; Delete the product with the specified id"},{"location":"architecture/cli/#feature-commands","title":"Feature commands","text":"Command Description lm-cli features list List all features lm-cli features list--search &lt;search string&gt; Search features with the specified string lm-cli features list--sort-field &lt;sort field&gt; Sort features by the specified field lm-cli features list--sort-field &lt;sort field&gt;--sort-order &lt;ascending or descending&gt; Sort features by the specified order lm-cli features get-one--id &lt;feature id&gt; List the feature with the specified id lm-cli features create--name &lt;feature name&gt;--product-id &lt;id of the product of the license&gt;--config-id &lt;id of the configuration of the license&gt;--reserved &lt;how many licenses should be reserved for desktop environments&gt; Create a new feature lm-cli features delete--id &lt;id to delete&gt; Delete the feature with the specified id"},{"location":"architecture/cli/#job-commands","title":"Job commands","text":"Command Description lm-cli jobs list List all jobs lm-cli jobs list--search &lt;search string&gt; Search jobs with the specified string lm-cli jobs list--sort-field &lt;sort field&gt; Sort jobs by the specified field lm-cli jobs list--sort-field &lt;sort field&gt;--sort-order &lt;ascending or descending&gt; Sort jobs by the specified order"},{"location":"architecture/cli/#booking-commands","title":"Booking commands","text":"Command Description lm-cli bookings list List all bookings lm-cli bookings list--search &lt;search string&gt; Search bookings with the specified string lm-cli bookings list--sort-field &lt;sort field&gt; Sort bookings by the specified field lm-cli bookings list--sort-field &lt;sort field&gt;--sort-order &lt;ascending or descending&gt; Sort bookings by the specified order"},{"location":"architecture/cli/#reference","title":"Reference","text":"<p>The reference page contains more information about the commands available.</p>"},{"location":"development/","title":"Development","text":"<p>The <code>License Manager</code> can be provisioned using two approaches:</p> <ul> <li>Use <code>Docker Compose</code> to run the services</li> <li>Create a <code>Slurm</code> cluster and <code>License Manager</code> components using <code>Juju</code>.  </li> </ul> <p>You can also provision the components manually, but this guide will focus on the two approaches mentioned above.</p>"},{"location":"development/#instructions","title":"Instructions","text":"<p>The guides below will walk you through the steps to provision the <code>License Manager</code> using the two approaches mentioned above.</p> <ul> <li> <p>Docker Compose</p> </li> <li> <p>Juju</p> </li> </ul>"},{"location":"development/docker_compose/","title":"Using Docker Compose","text":""},{"location":"development/docker_compose/#pre-installation","title":"Pre-Installation","text":"<p>Before you get started, ensure you have the following pre-requisites installed on your machine:</p> <ul> <li>docker</li> <li>docker compose</li> </ul>"},{"location":"development/docker_compose/#running-the-license-manager-composed","title":"Running the License Manager Composed","text":"<p>To get started, clone the <code>license-manager</code> repository from GitHub and run <code>docker compose up</code>.</p> <pre><code>git clone https://github.com/omnivector-solutions/license-manager\ncd license-manager/lm-composed\ndocker-compose up --build\n</code></pre> <p>The <code>docker compose</code> command will start the following services:</p> <ol> <li>License Manager API</li> <li>Postgresql database (for the License Manager API)</li> <li>Keycloak (authentication provider for the-LM API)</li> <li>License Manager Simulator API</li> <li>Postgresql database (for the License Manager Simulator API)</li> <li>Slurm cluster (Slurmctld, Slurmdbd, Slurmrestd, and two Slurmd containers)</li> </ol>"},{"location":"development/docker_compose/#submitting-a-job","title":"Submitting a job","text":"<ol> <li>Log into the <code>slurmctld</code> container:</li> </ol> <pre><code>docker compose exec slurmctld bash\n</code></pre> <ol> <li>Execute the job example:</li> </ol> <pre><code>sbatch /nfs/job_example.py\n</code></pre> <p>The job will request 42 licenses to the <code>License Manager Simulator API</code> and return it after a few minutes. It will be submitted to the Slurm cluster and the <code>License Manager Agent</code> will make a booking request to the <code>License Manager API</code>. The results will be available in the <code>slurm-fake-nfs</code> directory.</p>"},{"location":"development/juju/","title":"Setting up License Manager using Juju","text":""},{"location":"development/juju/#pre-installation","title":"Pre-Installation","text":"<p>Before you get started, ensure you have the following pre-requisites installed on your machine:</p> <ul> <li>snapd</li> <li>charmcraft</li> <li>LXD (latest/stable)</li> <li>juju</li> <li>poetry</li> <li>docker compose</li> <li>docker</li> </ul> <p>Additionally, assign the host machine's primary IP address to a variable <code>MY_IP</code>. We will use this value throughout the development environment setup process.</p> <pre><code>MY_IP=\"$(ip route get 1 | awk '{print $(NF-2);exit}')\"\n</code></pre>"},{"location":"development/juju/#1-deploy-a-local-slurm-cluster-on-lxd","title":"1. Deploy a local SLURM cluster on LXD","text":"<p>Follow the upstream documentation to deploy a local LXD slurm cluster that we can use in development.</p> <p>The general idea is to run <code>juju deploy slurm</code>, following which, you will have a local slurm cluster to use in development.</p> <p>After the deployment of slurm has completed and settled, the environment should resemble the following:</p> <pre><code>Model                    Controller           Cloud/Region         Version  SLA          Timestamp\nlicense-manager-testing  localhost-localhost  localhost/localhost  2.9.17   unsupported  06:46:42Z\n\nApp              Version  Status  Scale  Charm            Store     Channel  Rev  OS      Message\npercona-cluster  5.7.20   active      1  percona-cluster  charmhub  stable   302  ubuntu  Unit is ready\nslurmctld        0.8.1    active      1  slurmctld        charmhub  stable    17  ubuntu  slurmctld available\nslurmd           0.8.1    active      1  slurmd           charmhub  stable    26  ubuntu  slurmd available\nslurmdbd         0.8.1    active      1  slurmdbd         charmhub  stable    15  ubuntu  slurmdbd available\nslurmrestd       0.8.1    active      1  slurmrestd       charmhub  stable    15  ubuntu  slurmrestd available\n\nUnit                Workload  Agent  Machine  Public address  Ports     Message\npercona-cluster/0*  active    idle   0        10.20.96.130    3306/tcp  Unit is ready\nslurmctld/0*        active    idle   1        10.20.96.57               slurmctld available\nslurmd/0*           active    idle   2        10.20.96.233              slurmd available\nslurmdbd/0*         active    idle   3        10.20.96.123              slurmdbd available\nslurmrestd/0*       active    idle   4        10.20.96.62               slurmrestd available\n\nMachine  State    DNS           Inst id        Series  AZ  Message\n0        started  10.20.96.130  juju-b71748-0  bionic      Running\n1        started  10.20.96.57   juju-b71748-1  focal       Running\n2        started  10.20.96.233  juju-b71748-2  focal       Running\n3        started  10.20.96.123  juju-b71748-3  focal       Running\n4        started  10.20.96.62   juju-b71748-4  focal       Running\n</code></pre> <p>Following the deployment, run the action to enlist the <code>slurmd</code> node and set its state to idle.</p> <pre><code>juju run-action slurmd/0 node-configured\n</code></pre> <p>Lastly, validate that the node has successfully enlisted and the cluster is operational.</p> <pre><code>$ juju ssh slurmd/0 sinfo\nPARTITION  AVAIL  TIMELIMIT  NODES  STATE NODELIST\nosd-slurmd    up   infinite      1   idle juju-b71748-2\n\n$ juju ssh slurmd/0 srun -posd-slurmd hostname\njuju-b71748-2\n</code></pre> <p>The slurm cluster is now prepared for further configuration and use in <code>License Manager</code> development.</p>"},{"location":"development/juju/#2-compose-the-license-manager-api","title":"2. Compose the License Manager API","text":"<p>Setting up the <code>License Manager API</code> for development is done in three steps:</p> <ol> <li>Clone the project to your local machine</li> <li>Run <code>make local</code></li> <li>Initialize the database with a license configuration for testing.</li> </ol> <p>To get started, clone the <code>license-manager</code> repository from GitHub and run <code>make local</code>.</p> <pre><code>git clone https://github.com/omnivector-solutions/license-manager\ncd license-manager/lm-api\nmake local\n</code></pre> <p>We should now see two running docker containers; <code>lm-api-license-manager-1</code> and <code>lm-api-pgsql-1</code>.</p> <p><code>docker ps</code> shows:</p> <pre><code>$ docker ps\nCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS                PORTS                    NAMES\nff6fcdcc7fdc   lm-api-license-manager   \"uvicorn lm_api.main\u2026\"   40 seconds ago   Up 35 seconds         0.0.0.0:7000-&gt;8000/tcp   lm-api-license-manager-1\n095cdd03027e   postgres:13-alpine       \"docker-entrypoint.s\u2026\"   2 weeks ago      Up 4 days (healthy)   0.0.0.0:5433-&gt;5432/tcp   lm-api-test-db-1\n32c70f6fb586   postgres:13-alpine       \"docker-entrypoint.s\u2026\"   2 weeks ago      Up 4 days (healthy)   0.0.0.0:5432-&gt;5432/tcp   lm-api-pgsql-1\n</code></pre> <p>From the output above, we see that port <code>7000</code> on our local machine is forwarded to the listening port of the <code>License Manager API</code> container (port <code>8000</code>). This means we will make requests to our local host IP address at port <code>7000</code> in order to access the <code>License Manager API</code> HTTP endpoints.</p> <p>Now initialize the API with the following resources that we can use for testing:</p> <ol> <li>Product</li> <li>Configuration (with Feature and License Server included)</li> </ol> <pre><code>PRODUCT_ID=$(curl -X 'POST' \\\n  'http://'$MY_IP':7000/lm/products/' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"name\": \"test_product\"\n  }' | jq '.id')\n\n\ncurl -X 'POST' \\\n  'http://'$MY_IP':7000/lm/configurations/' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"name\": \"Test License\",\n  \"cluster_client_id\": \"osd-cluster\",\n  \"features\": {\n    \"name\": \"test_feature\",\n    \"product_id\": '$PRODUCT_ID',\n    \"reserved\": 0\n  },\n  \"license_servers\": {\n    \"host\": $MY_IP,\n    \"port\": 8000\n  },\n  \"grace_time\": 300,\n  \"type\": \"flexlm\"\n}\n</code></pre> <p>You can check that the resources were successfully added by making a request to list the configurations in the database (this list should contain the license you previously added).</p> <pre><code>curl -X 'GET' \\\n  'http://'$MY_IP':7000/lm/configurations' \\\n  -H 'accept: application/json'\n</code></pre> <pre><code>[\n  {\n    \"id\": 1,\n    \"name\": \"Test License\",\n    \"cluster_client_id\": \"osd-cluster\",\n    \"features\": [\n      {\n        \"id\": 1,\n        \"name\": \"test_feature\",\n        \"product\": {\n          \"id\": 1,\n          \"name\": \"test_product\"\n        },\n        \"config_id\": 1,\n        \"reserved\": 0,\n        \"total\": 0,\n        \"used\": 0\n      }\n    ],\n    \"license_servers\": [\n      {\n        \"id\": 1,\n        \"config_id\": 1,\n        \"host\": 127.0.0.1,\n        \"port\": 8000\n      }\n    ],\n    \"grace_time\": 300,\n    \"type\": \"flexlm\"\n  }\n]\n</code></pre> <p>The <code>License Manager API</code> is now configured and ready for use in the development environment.</p>"},{"location":"development/juju/#3-compose-the-license-manager-simulator","title":"3. Compose the License Manager Simulator","text":"<p>To run the <code>License Manager Simulator</code> API, enter the directory <code>lm-simulator-api</code> and run <code>make local</code>.</p> <pre><code>cd license-manager/lm-simulator-api\nmake local\n</code></pre> <p>The <code>License Manager Simulator</code> API is now running and listening on port <code>8000</code>. You need to add the license created in the <code>License Manager API</code> into the <code>License Manager Simulator API</code>. The license name should match the feature name created previously.</p> <pre><code>curl -X 'POST' \\\n  'http://'$MY_IP':8000/lm-sim/licenses/' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"name\": \"test_feature\",\n  \"total\": 1000,\n  \"license_server_type\": \"flexlm\"\n}'\n</code></pre>"},{"location":"development/juju/#4-add-the-license-manager-agent-to-the-cluster","title":"4. Add the License Manager Agent to the cluster","text":"<p>The final component we need to deploy is the <code>License Manager Agent</code>. The <code>License Manager Agent</code> is deployed to the same model as the slurm charms, and related to <code>slurmctld</code>.</p> <pre><code>git clone git@github.com:omnivector-solutions/charm-license-manager-agent\ncd charm-license-manager-agent/\nmake charm\n</code></pre> <p>The <code>make charm</code> command will produce a resultant charm artifact named <code>license-manager-agent.charm</code>. This is the charm that we will deploy.</p> <p>Before deploying the charm, create a <code>yaml</code> configuration file that contains the needed settings for the <code>License Manager Agent Charm</code>. The config should look something like this:</p> <pre><code>license-manager-agent:\n  log-level: DEBUG\n  stat-interval: 30\n  license-manager-backend-base-url: \"http://\"$MY_IP\":7000\"\n  lmutil-path: \"/usr/local/bin/lmutil\"\n  rlmutil-path: \"/usr/local/bin/rlmutil\"\n  lsdyna-path: \"/usr/local/bin/lstc_qrun\"\n  lmxendutil-path: \"/usr/local/bin/lmxendutil\"\n  olixtool-path: \"/usr/local/bin/olixtool\"\n  dslicsrv-path: \"/usr/local/bin/dslicsrv\"\n  oidc-domain: \"your-oidc-domain\"\n  oidc-client-id: \"your-oidc-client-id\"\n  oidc-client-secret: \"your-oidc-client-secret\"\n  sentry-dsn: \"\"\n</code></pre> <p>Make sure to substitute the correct values into the new <code>license-manager-agent.yaml</code> configuration file (especially the IP address of your host machine). You'll also need to provision an OIDC instance to authenticate against the backend API.</p> <p>Now that we have the charm artifact (<code>license-manager-agent.charm</code>) and the config file for the charm (<code>license-manager-agent.yaml</code>), we are ready to deploy.</p> <p>Using <code>juju</code>, deploy the <code>license-manager-agent</code> charm to the model, specifying the config file as an argument to the deploy command.</p> <pre><code>juju deploy ./license-manager-agent.charm \\\n    --config ./license-manager-agent.yaml --series focal\n</code></pre> <p>After the deploy, make sure to relate the charm to the juju-info and prolog-epilog interface.</p> <pre><code>juju relate license-manager-agent:juju-info slurmctld\njuju relate license-manager-agent:prolog-epilog slurmctld\n</code></pre>"},{"location":"development/juju/#5-additional-modifications","title":"5. Additional Modifications","text":"<p>At this point you should have 3 systems running:</p> <ol> <li>Slurm cluster in LXD</li> <li>License Manager Simulator API</li> <li>License Manager API</li> </ol> <p>Once the systems have been successfully deployed you will need to apply the post deployment configurations. These configurations will ensure that your slurm cluster has a fake license server client and available licenses to be used by the fake application (which will be run as a batch script).</p>"},{"location":"development/juju/#configuring-the-license-server-client","title":"Configuring the license server client","text":"<p>The <code>License Manager Simulator</code> has a script for each license server supported (FlexLM, RLM, LS-Dyna, LM-X, OLicense and DSLS). The script requests license information from the <code>License Manager Simulator API</code> and renders it in a template, simulating the output from the real license server.</p> <p>To configure it, you need to install the <code>License Manager Simulator</code> package inside the same virtual environment created for <code>License Manager Agent</code>.</p> <p>By default, the <code>License Manager Agent</code> uses the virtual environment located at <code>/srv/license-manager-agent-venv</code>. To install the <code>License Manager Simulator</code> package, run the following command:</p> <pre><code>juju ssh license-manager-agent/0\nsource /srv/license-manager-agent-venv/bin/activate\npip install license-manager-simulator\n</code></pre> <p>After installing the License Manager Simulator, you need to update the configuration to use the path for the created binaries.</p> <pre><code>juju config license-manager-agent lmutil-path=/srv/license-manager-agent-venv/bin/lmutil\njuju config license-manager-agent rlmutil-path=/srv/license-manager-agent-venv/bin/rlmutil\njuju config license-manager-agent lsdyna-path=/srv/license-manager-agent-venv/bin/lstc_qrun\njuju config license-manager-agent lmxendutil-path=/srv/license-manager-agent-venv/bin/lmxendutil\njuju config license-manager-agent olixtool-path=/srv/license-manager-agent-venv/bin/olixtool\njuju config license-manager-agent dslicsrv-path=/srv/license-manager-agent-venv/bin/dslicsrv\n</code></pre>"},{"location":"development/juju/#configuring-the-slurm-license-counter","title":"Configuring the Slurm license counter","text":"<p>You need to add a license counter to Slurm to match the license created in the <code>License Manager API</code> and the <code>License Manager Simulator API</code>.</p> <p>To do this, you need to add the following configuration to the <code>slurmdctld</code> machine:</p> <pre><code>juju ssh slurmctld/0\nsudo sacctmgr add resource Type=license Clusters=osd-cluster Server=flexlm Names=test_product.test_feature Count=1000 ServerType=flexlm PercentAllowed=100 -i\n</code></pre>"},{"location":"development/juju/#using-the-simulated-license-server","title":"Using the simulated license server","text":"<p>You should now have a license for testing available. To check the output of the simulated license server, you can run:</p> <pre><code>juju ssh license-manager-agent/0\n/srv/license-manager-agent-venv/bin/lmutil lmstat -c 8000@127.0.0.1 -f test_Feature\n</code></pre> <p>The output should display the \"test_product.test_feature\" license that was added to the <code>License Manager Simulator</code>:</p> <pre><code>lmutil - Copyright (c) 1989-2012 Flexera Software LLC. All Rights Reserved.\nFlexible License Manager status on Thu 10/29/2020 17:44\n\nLicense server status: server1,server2,server3\n    License file(s) on server1: f:\\flexlm\\AbaqusLM\\License\\license.dat:\n\nserver1: license server UP v11.13\nserver2: license server UP (MASTER) v11.13\nserver3: license server UP v11.13\n\nVendor daemon status (on server2):\n  FakeLM: UP v11.13\n\nFeature usage info:\n\nUsers of test_feature:  (Total of 1000 licenses issued;  Total of 0 licenses in use)\n\n  \"test_product\" v62.2, vendor: FakeLM\n\n  floating license\n</code></pre>"},{"location":"development/juju/#seeding-the-batch-script-and-fake-application","title":"Seeding the batch script and fake application","text":"<p>To test the <code>License Manager</code>, you need to run a fake application that will request licenses from the <code>License Manager Simulator</code> API, and a batch script that will schedule the fake application job in the slurm cluster.</p> <p>The fake application makes a request to the <code>License Manager Simulator</code> API to book 42 <code>test_feature</code> licenses, sleeps for a few seconds, and then deletes the booking. The batch script will be responsible for scheduling the fake application job in the slurm cluster.</p> <p>To run it, you need to modify the IP address in the <code>application.sh</code> file to match the IP where the <code>License Manager Simulator API</code> is running.</p> <p>After that, copy the files to the <code>/tmp</code> directory in the <code>slurmd</code> machine.</p> <p>To run the job, use the <code>sbatch</code> command.</p> <pre><code>juju ssh slurmd/0 sbatch /tmp/batch.sh\n</code></pre>"},{"location":"development/juju/#6-validation","title":"6. Validation","text":"<p>After following the steps above, you should have a working development environment. To validate that it is indeed working, submit a job to slurm (using the batch script) and check <code>License Manager API</code>.</p> <p>Make a request to the <code>features</code> endpoint.</p> <pre><code>curl -X 'GET' \\\n  'http://'$MY_IP':7000/lm/features' \\\n  -H 'accept: application/json'\n</code></pre> <p>You should see that the <code>used</code> value for the license was updated with the value used in the job (42).</p> <pre><code>[\n  {\n    \"id\": 1,\n    \"name\": \"test_feature\",\n    \"product\": {\n      \"id\": 1,\n      \"name\": \"test_product\"\n    },\n    \"config_id\": 1,\n    \"reserved\": 0,\n    \"total\": 1000,\n    \"used\": 42,\n    \"booked_total\": 0\n    }\n]\n</code></pre> <p>You also should have a new job created. To verify this, make a request to the <code>jobs</code> endpoint.</p> <pre><code>curl -X 'GET' \\\n  'http://'$MY_IP:7000'/lm/jobs' \\\n  -H 'accept: application/json'\n</code></pre> <p>The job should contain information about the job and also how many licenses were booked by the job.</p> <pre><code>[\n  {\n    \"id\": 1,\n    \"slurm_job_id\": \"1\",\n    \"cluster_client_id\": \"osd-cluster\",\n    \"username\": \"ubuntu\",\n    \"lead_host\": \"juju-d9201d-2\",\n    \"bookings\": [\n      {\n        \"id\": 1,\n        \"job_id\": 1,\n        \"feature_id\": 1,\n        \"quantity\": 42\n      }\n    ]\n  }\n]\n</code></pre> <p>Wait for a few seconds (for the reconcile to run) and check again. The job and the booking should be deleted and the <code>used</code> value will return to its original quantity.</p>"},{"location":"reference/agent/","title":"License Manager Agent Reference","text":""},{"location":"reference/agent/#license-server-parsers","title":"License Server Parsers","text":""},{"location":"reference/agent/#lm_agent.parsing.flexlm","title":"lm_agent.parsing.flexlm","text":"<p>Parser for FlexLM</p>"},{"location":"reference/agent/#lm_agent.parsing.flexlm.parse","title":"parse","text":"<pre><code>parse(server_output: str) -&gt; Dict\n</code></pre> <p>Parse the FlexLM Output, using regext to match the lines we need: - <code>feature line</code>: info about the license - <code>data line</code>: info about the users using the license</p>"},{"location":"reference/agent/#lm_agent.parsing.flexlm.parse_feature_line","title":"parse_feature_line","text":"<pre><code>parse_feature_line(line: str) -&gt; Optional[Dict]\n</code></pre> <p>Parse the feature line in the FlexLM output. Data we need: - <code>feature</code>: license name - <code>total</code>: total amount of licenses - <code>used</code>: quantity of licenses being used</p>"},{"location":"reference/agent/#lm_agent.parsing.flexlm.parse_usage_line","title":"parse_usage_line","text":"<pre><code>parse_usage_line(line: str) -&gt; Optional[LicenseUsesItem]\n</code></pre> <p>Parse the usage line in the FlexLM output. Data we need: - <code>username</code>: user who booked the license - <code>lead_host</code>: host using the license - <code>booked</code>: quantity of licenses being used</p> <p>There can be multiple formats for the data line, so we need to check which one matches.</p>"},{"location":"reference/agent/#lm_agent.parsing.rlm","title":"lm_agent.parsing.rlm","text":"<p>Parser for RLM</p>"},{"location":"reference/agent/#lm_agent.parsing.rlm.parse","title":"parse","text":"<pre><code>parse(server_output: str) -&gt; dict\n</code></pre> <p>Parse the output from the RLM server. Data we need: - <code>feature</code>: license name - <code>count</code>: total amount of licenses - <code>in_use</code>: quantity of licenses being use</p>"},{"location":"reference/agent/#lm_agent.parsing.rlm.parse_count_line","title":"parse_count_line","text":"<pre><code>parse_count_line(line: str) -&gt; Optional[dict]\n</code></pre> <p>Parse the count line in the RLM output. Data we need: - <code>count</code>: total amount of licenses - <code>in_use</code>: quantity of licenses being use</p>"},{"location":"reference/agent/#lm_agent.parsing.rlm.parse_feature_line","title":"parse_feature_line","text":"<pre><code>parse_feature_line(line: str) -&gt; Optional[str]\n</code></pre> <p>Parse the feature line in the RLM output. Data we need: - <code>feature</code>: license name</p>"},{"location":"reference/agent/#lm_agent.parsing.rlm.parse_usage_line","title":"parse_usage_line","text":"<pre><code>parse_usage_line(line: str) -&gt; Optional[dict]\n</code></pre> <p>Parse the usage line in the RLM output. Data we need: - <code>feature</code>: license name - <code>username</code>: user name - <code>lead_host</code>: lead host - <code>license_used_by_host</code>: quantity of licenses being use</p>"},{"location":"reference/agent/#lm_agent.parsing.lsdyna","title":"lm_agent.parsing.lsdyna","text":"<p>Parser for LS-Dyna</p>"},{"location":"reference/agent/#lm_agent.parsing.lsdyna.parse","title":"parse","text":"<pre><code>parse(s: str)\n</code></pre> <p>Parse the LS-Dyna output, using regex to match the lines we need: - <code>program line</code>: info about each license - <code>usage line</code>: info about users using licenses - <code>total line</code>: info about the pool, which affects all licenses</p> <p>Since the usage line doesn't have the name of the license in use, we're saving each parsed license in a list. This way, we can find which license the user is using by checking the last parsed license in this list.</p> <p>Also, all the licenses in the server will have their <code>used</code> value filled with the group used value, since it'll reflect the correct amount of free licenses in the pool.</p>"},{"location":"reference/agent/#lm_agent.parsing.lsdyna.parse_program_line","title":"parse_program_line","text":"<pre><code>parse_program_line(line: str)\n</code></pre> <p>Parse the program line in the LS-Dyna output. Data we need: - <code>program</code>: license name - <code>max</code>: total amount of licenses in the server The <code>used</code>value will be evaluated later.</p>"},{"location":"reference/agent/#lm_agent.parsing.lsdyna.parse_total_line","title":"parse_total_line","text":"<pre><code>parse_total_line(line: str)\n</code></pre> <p>Parse the total line in the LS-Dyna output. Data we need: - <code>used</code>: quantity of licenses being used in the server</p> <p>Obs: all LS-Dyna licenses in the server share the same license pool, where the amount of available licenses can be consumed by any license in the server.</p> <p>The <code>used</code> value is the sum of all licenses in use in the pool. Since we calculate the available quantity as <code>available = total - used</code>, we'll use the group <code>used</code> value for all licenses, so the available will reflect the correct amount of free licenses in the pool.</p>"},{"location":"reference/agent/#lm_agent.parsing.lsdyna.parse_usage_line","title":"parse_usage_line","text":"<pre><code>parse_usage_line(line: str)\n</code></pre> <p>Parse the usage line in the LS-Dyna output. Data we need: - <code>username</code>: user who booked the license - <code>lead_host</code>: host using the license - <code>booked</code>: quantity of licenses being used</p> <p>Obs: this line doesn't include the license name. The license in use is the last one parsed before this line.</p>"},{"location":"reference/agent/#lm_agent.parsing.lmx","title":"lm_agent.parsing.lmx","text":"<p>Parser for LM-X</p>"},{"location":"reference/agent/#lm_agent.parsing.lmx.parse","title":"parse","text":"<pre><code>parse(server_output: str) -&gt; dict\n</code></pre> <p>Parse the LM-X output using regex to match the lines we need: -<code>feature line</code>: info about each license -<code>in use line</code>: info about licenses in use -<code>usage line</code>: info about users using licenses</p> <p>Since the in use and usage line don't have the name of the license in use, we're saving each parsed license in a list. This way, we can find which license is being used by checking the last parsed license in the list.</p>"},{"location":"reference/agent/#lm_agent.parsing.lmx.parse_feature_line","title":"parse_feature_line","text":"<pre><code>parse_feature_line(line: str) -&gt; Optional[str]\n</code></pre> <p>Parse the feature line in the LM-X output. Data we need: - <code>feature</code>: license name</p>"},{"location":"reference/agent/#lm_agent.parsing.lmx.parse_in_use_line","title":"parse_in_use_line","text":"<pre><code>parse_in_use_line(line: str) -&gt; Optional[dict]\n</code></pre> <p>Parse the in use line in the LM-X output. Data we need: - <code>in_use</code>: quantity of licenses being use - <code>total</code>: total amount of licenses</p> <p>Obs: this line doesn't include the license name. The license in use is the last one parsed before this line.</p>"},{"location":"reference/agent/#lm_agent.parsing.lmx.parse_usage_line","title":"parse_usage_line","text":"<pre><code>parse_usage_line(line: str) -&gt; Optional[LicenseUsesItem]\n</code></pre> <p>Parse the usage line in the LS-Dyna output. Data we need: -<code>username</code>: user who booked the license -<code>lead_host</code>: host using the license -<code>booked</code>: quantity of licenses being used</p> <p>Obs: this line also doesn't incluse the license name. The license in use is the last one parsed before this line.</p>"},{"location":"reference/agent/#lm_agent.parsing.olicense","title":"lm_agent.parsing.olicense","text":"<p>Parser for OLicense</p>"},{"location":"reference/agent/#lm_agent.parsing.olicense.parse","title":"parse","text":"<pre><code>parse(server_output: str) -&gt; dict\n</code></pre> <p>Parse the OLicense output using regex to match the lines we need: -<code>feature line</code>: info about each license -<code>in use line</code>: info about licenses in use -<code>usage line</code>: info about users using licenses</p> <p>Since the \"in use\" and \"usage\" lines don't have the name of the license in use, we're saving each parsed license in a list. This way, we can find which license is being used by checking the last parsed license in the list.</p> <p>If a feature has more than one license associated with it, the total amount of licenses is the sum of all licenses with the same name.</p> Example of output <p>... ftire_adams;            FreeFloating;   3;      2022-12-31 23:59:59; 1 FloatsLockedBy: sbhyma@RD0087712 #1 ... ftire_adams;            FreeFloating;   1;      2023-02-28 23:59:00;</p> This would be parsed as <p>\"ftire_adams\": {\"total\": 4, \"used\" 1, \"uses\": {     \"user_name\": \"sbhyma\", \"lead_host\": \"RD0087712\", \"booked\": 1 }}</p>"},{"location":"reference/agent/#lm_agent.parsing.olicense.parse_feature_line","title":"parse_feature_line","text":"<pre><code>parse_feature_line(line: str) -&gt; Optional[dict]\n</code></pre> <p>Parse the \"feature\" line in the OLicense output. Data we need: - <code>feature</code>: license name - <code>total</code>: total amount of licenses</p> <p>Obs: OLicense supports more than one license with the same feature name. In case a feature has more than one license associated with it, the total amount of licenses is the sum of all licenses with the same name.</p>"},{"location":"reference/agent/#lm_agent.parsing.olicense.parse_in_use_line","title":"parse_in_use_line","text":"<pre><code>parse_in_use_line(line: str) -&gt; Optional[int]\n</code></pre> <p>Parse the \"in use\" line in the Olicense output. Data we need: - <code>in_use</code>: quantity of licenses being used by each user</p> <p>Obs: this line doesn't include the license name. The license in use is the last one parsed before this line. It also doesn't include the user name. The user using the license is the next \"usage\" line parsed after this line. The total amount of licenses being used is the sum of all \"in use\" lines.</p>"},{"location":"reference/agent/#lm_agent.parsing.olicense.parse_usage_line","title":"parse_usage_line","text":"<pre><code>parse_usage_line(line: str) -&gt; Optional[LicenseUsesItem]\n</code></pre> <p>Parse the usage line in the Olicense output. Data we need: -<code>username</code>: user who booked the license -<code>lead_host</code>: host using the license -<code>booked</code>: quantity of licenses booked by the user</p> <p>Obs: this line also doesn't include the license name. The license in use is the last one parsed before this line.</p>"},{"location":"reference/agent/#lm_agent.parsing.dsls","title":"lm_agent.parsing.dsls","text":"<p>Parser for DSLS.</p>"},{"location":"reference/agent/#lm_agent.parsing.dsls.parse","title":"parse","text":"<pre><code>parse(server_output: str) -&gt; dict[str, ParsedFeatureItem]\n</code></pre> <p>Parse the output from the DSLS server. Data we need: - <code>feature</code>: license name - <code>count</code>: total amount of licenses - <code>in_use</code>: quantity of licenses being use - <code>uses</code>: list of users using the license</p> <p>Obs: if the feature is used by multiple users, each usage will result in a line with the same feature information, just changing the usage data.</p>"},{"location":"reference/agent/#lm_agent.parsing.dsls.parse_feature_dict","title":"parse_feature_dict","text":"<pre><code>parse_feature_dict(feature_dict: dict[str, str]) -&gt; Optional[ParsedFeatureItem]\n</code></pre> <p>Parse the feature dcit in the DSLS output.</p> <p>Data we need: - <code>feature</code>: license name - <code>total</code>: total amount of licenses - <code>used</code>: quantity of licenses being used</p>"},{"location":"reference/agent/#lm_agent.parsing.dsls.parse_usage_dict","title":"parse_usage_dict","text":"<pre><code>parse_usage_dict(usage_dict: dict[str, str]) -&gt; Optional[LicenseUsesItem]\n</code></pre> <p>Parse the usage dict in the DSLS output.</p> <p>Data we need: - <code>username</code>: user who booked the license - <code>lead_host</code>: host using the license - <code>booked</code>: quantity of licenses being used</p>"},{"location":"reference/agent/#license-server-interfaces","title":"License Server Interfaces","text":""},{"location":"reference/agent/#lm_agent.server_interfaces.flexlm","title":"lm_agent.server_interfaces.flexlm","text":"<p>FlexLM license server interface.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.flexlm.FlexLMLicenseServer","title":"FlexLMLicenseServer","text":"<p>               Bases: <code>LicenseServerInterface</code></p> <p>Extract license information from FlexLM license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.flexlm.FlexLMLicenseServer.get_commands_list","title":"get_commands_list","text":"<pre><code>get_commands_list() -&gt; typing.List[typing.List[str]]\n</code></pre> <p>Generate a list of commands with the available license server hosts.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.flexlm.FlexLMLicenseServer.get_output_from_server","title":"get_output_from_server  <code>async</code>","text":"<pre><code>get_output_from_server(product_feature: str)\n</code></pre> <p>Override abstract method to get output from FlexLM license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.flexlm.FlexLMLicenseServer.get_report_item","title":"get_report_item  <code>async</code>","text":"<pre><code>get_report_item(feature_id: int, product_feature: str)\n</code></pre> <p>Override abstract method to parse FlexLM license server output into License Report Item.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.rlm","title":"lm_agent.server_interfaces.rlm","text":"<p>RLM license server interface.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.rlm.RLMLicenseServer","title":"RLMLicenseServer","text":"<p>               Bases: <code>LicenseServerInterface</code></p> <p>Extract license information from RLM license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.rlm.RLMLicenseServer.get_commands_list","title":"get_commands_list","text":"<pre><code>get_commands_list() -&gt; typing.List[typing.List[str]]\n</code></pre> <p>Generate a list of commands with the available license server hosts.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.rlm.RLMLicenseServer.get_output_from_server","title":"get_output_from_server  <code>async</code>","text":"<pre><code>get_output_from_server()\n</code></pre> <p>Override abstract method to get output from RLM license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.rlm.RLMLicenseServer.get_report_item","title":"get_report_item  <code>async</code>","text":"<pre><code>get_report_item(feature_id: int, product_feature: str)\n</code></pre> <p>Override abstract method to parse RLM license server output into License Report Item.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lsdyna","title":"lm_agent.server_interfaces.lsdyna","text":"<p>LS-Dyna license server interface.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lsdyna.LSDynaLicenseServer","title":"LSDynaLicenseServer","text":"<p>               Bases: <code>LicenseServerInterface</code></p> <p>Extract license information from LS-Dyna license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lsdyna.LSDynaLicenseServer.__init__","title":"__init__","text":"<pre><code>__init__(license_servers: typing.List[LicenseServerSchema])\n</code></pre> <p>Initialize the license server instance with the license server host and parser.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lsdyna.LSDynaLicenseServer.get_commands_list","title":"get_commands_list","text":"<pre><code>get_commands_list() -&gt; typing.List[typing.List[str]]\n</code></pre> <p>Generate a list of commands with the available license server hosts.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lsdyna.LSDynaLicenseServer.get_output_from_server","title":"get_output_from_server  <code>async</code>","text":"<pre><code>get_output_from_server()\n</code></pre> <p>Override abstract method to get output from Ls-Dyna license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lsdyna.LSDynaLicenseServer.get_report_item","title":"get_report_item  <code>async</code>","text":"<pre><code>get_report_item(feature_id: int, product_feature: str)\n</code></pre> <p>Override abstract method to parse LS-Dyna license server output into License Report Item.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lmx","title":"lm_agent.server_interfaces.lmx","text":"<p>LM-X license server interface.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lmx.LMXLicenseServer","title":"LMXLicenseServer","text":"<p>               Bases: <code>LicenseServerInterface</code></p> <p>Extract license information from LM-X license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lmx.LMXLicenseServer.__init__","title":"__init__","text":"<pre><code>__init__(license_servers: typing.List[LicenseServerSchema])\n</code></pre> <p>Initialize the license server instance with the license server host and parser.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lmx.LMXLicenseServer.get_commands_list","title":"get_commands_list","text":"<pre><code>get_commands_list() -&gt; typing.List[typing.List[str]]\n</code></pre> <p>Generate a list of commands with the available license server hosts.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lmx.LMXLicenseServer.get_output_from_server","title":"get_output_from_server  <code>async</code>","text":"<pre><code>get_output_from_server()\n</code></pre> <p>Override abstract method to get output from LM-X license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.lmx.LMXLicenseServer.get_report_item","title":"get_report_item  <code>async</code>","text":"<pre><code>get_report_item(feature_id: int, product_feature: str)\n</code></pre> <p>Override abstract method to parse LM-X license server output into License Report Item.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.olicense","title":"lm_agent.server_interfaces.olicense","text":"<p>OLicense license server interface.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.olicense.OLicenseLicenseServer","title":"OLicenseLicenseServer","text":"<p>               Bases: <code>LicenseServerInterface</code></p> <p>Extract license information from OLicense license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.olicense.OLicenseLicenseServer.__init__","title":"__init__","text":"<pre><code>__init__(license_servers: typing.List[LicenseServerSchema])\n</code></pre> <p>Initialize the license server instance with the license server host and parser.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.olicense.OLicenseLicenseServer.get_commands_list","title":"get_commands_list","text":"<pre><code>get_commands_list() -&gt; typing.List[typing.List[str]]\n</code></pre> <p>Generate a list of commands with the available license server hosts.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.olicense.OLicenseLicenseServer.get_output_from_server","title":"get_output_from_server  <code>async</code>","text":"<pre><code>get_output_from_server()\n</code></pre> <p>Override abstract method to get output from OLicense license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.olicense.OLicenseLicenseServer.get_report_item","title":"get_report_item  <code>async</code>","text":"<pre><code>get_report_item(feature_id: int, product_feature: str)\n</code></pre> <p>Override abstract method to parse OLicense license server output into License Report Item.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.dsls","title":"lm_agent.server_interfaces.dsls","text":"<p>DSLS license server interface.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.dsls.DSLSLicenseServer","title":"DSLSLicenseServer","text":"<p>               Bases: <code>LicenseServerInterface</code></p> <p>Extract license information from DSLS license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.dsls.DSLSLicenseServer.__init__","title":"__init__","text":"<pre><code>__init__(license_servers: typing.List[LicenseServerSchema])\n</code></pre> <p>Initialize the license server instance with the license server host and parser.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.dsls.DSLSLicenseServer.get_commands_list","title":"get_commands_list","text":"<pre><code>get_commands_list() -&gt; typing.List[typing.Dict]\n</code></pre> <p>Generate a list of commands with the available license server hosts.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.dsls.DSLSLicenseServer.get_output_from_server","title":"get_output_from_server  <code>async</code>","text":"<pre><code>get_output_from_server()\n</code></pre> <p>Override abstract method to get output from DSLS license server.</p>"},{"location":"reference/agent/#lm_agent.server_interfaces.dsls.DSLSLicenseServer.get_report_item","title":"get_report_item  <code>async</code>","text":"<pre><code>get_report_item(feature_id: int, product_feature: str)\n</code></pre> <p>Override abstract method to parse DSLS license server output into License Report Item.</p>"},{"location":"reference/agent/#license-server-services","title":"License Server Services","text":""},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings","title":"lm_agent.services.clean_jobs_and_bookings","text":"<p>Service to clean jobs and bookings that are no longer needed.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.clean_bookings_by_usage","title":"clean_bookings_by_usage  <code>async</code>","text":"<pre><code>clean_bookings_by_usage(cluster_jobs: List[JobSchema], license_report: List[LicenseReportItem])\n</code></pre> <p>Delete bookings if they match with a usage line in the license report.</p> <p>The bookings and the usage lines are mapped by a unique key composed by: * feature_id * username * lead_host * quantity</p> <p>This will group all bookings and all usages with the same information.</p> <p>The bookings can be deleted if the number of usages with the key matches the number of bookings with the key.</p> <ul> <li> <p>If there are more than one booking matching with the same usage, there's no way of knowning which booking relates to the usage. In this case, the bookings should be deleted by the grace time clean up.</p> </li> <li> <p>If there are more than one usage matching the same booking, the booking could relate to any of the usages. In this case, the booking should be deleted by the grace time clean up.</p> </li> </ul> <p>If there's an equal amount of usages and bookings, all the bookings have checked out their licenses from the license server, which means the bookings can be safely deleted by this clean up.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.clean_jobs_and_bookings","title":"clean_jobs_and_bookings  <code>async</code>","text":"<pre><code>clean_jobs_and_bookings(cluster_configurations: List[ConfigurationSchema], cluster_jobs: List[JobSchema], squeue_result: List[Dict], license_report: List[LicenseReportItem])\n</code></pre> <p>Clean the jobs and bookings that are no longer needed.</p> <p>The jobs can be deleted by: * Deleting the jobs that don't have any bookings. * Deleting the jobs that are no longer running. * Deleting the jobs that are running longer than the grace time.</p> <p>The bookings can be deleted by: * Deleting the bookings that have checked out their licenses from the license server.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.clean_jobs_by_grace_time","title":"clean_jobs_by_grace_time  <code>async</code>","text":"<pre><code>clean_jobs_by_grace_time(cluster_jobs: List[JobSchema], squeue_result: List[Dict], grace_times: Dict[int, int]) -&gt; List[JobSchema]\n</code></pre> <p>Clean the jobs where running time is greater than the grace_time.</p> <p>If the job has more than one booking, it will be deleted once the running time is greater than the greatest grace_time for any of the bookings.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.clean_jobs_no_longer_running","title":"clean_jobs_no_longer_running  <code>async</code>","text":"<pre><code>clean_jobs_no_longer_running(cluster_jobs: List[JobSchema], squeue_result: List[Dict]) -&gt; List[JobSchema]\n</code></pre> <p>Clean the jobs that aren't running along with its bookings.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.clean_jobs_without_bookings","title":"clean_jobs_without_bookings  <code>async</code>","text":"<pre><code>clean_jobs_without_bookings(cluster_jobs: List[JobSchema]) -&gt; List[JobSchema]\n</code></pre> <p>Clean the jobs that don't have any bookings.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.extract_bookings_from_job","title":"extract_bookings_from_job","text":"<pre><code>extract_bookings_from_job(job: JobSchema) -&gt; List[ExtractedBookingSchema]\n</code></pre> <p>Extract all the bookings information from a job.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.extract_usages_from_report","title":"extract_usages_from_report","text":"<pre><code>extract_usages_from_report(report_item: LicenseReportItem) -&gt; List[ExtractedUsageSchema]\n</code></pre> <p>Extract all the the usage information from a feature report</p> <p>Note that the lead_host from the license server comes with the full domain, but the lead_host from the job comes without the domain. This is why the lead_host is split by the dot and only the first part is used.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.get_bookings_mapping","title":"get_bookings_mapping","text":"<pre><code>get_bookings_mapping(cluster_jobs: List[JobSchema]) -&gt; Dict[Tuple[int, str, str, int], List[ExtractedBookingSchema]]\n</code></pre> <p>Map the bookings by creating a key with the required information for the matching.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.get_cluster_grace_times","title":"get_cluster_grace_times","text":"<pre><code>get_cluster_grace_times(cluster_configurations: List[ConfigurationSchema]) -&gt; Dict[int, int]\n</code></pre> <p>Get the grace time for each feature_id in the cluster.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.get_greatest_grace_time_for_job","title":"get_greatest_grace_time_for_job","text":"<pre><code>get_greatest_grace_time_for_job(grace_times: Dict[int, int], job_bookings: List[BookingSchema]) -&gt; int\n</code></pre> <p>Find the greatest grace time among the features booked by the given job_id.</p> <p>If the job has more than one booking, only the greatest grace time will be returned.</p>"},{"location":"reference/agent/#lm_agent.services.clean_jobs_and_bookings.get_usages_mapping","title":"get_usages_mapping","text":"<pre><code>get_usages_mapping(license_report: List[LicenseReportItem]) -&gt; Dict[Tuple[int, str, str, int], List[ExtractedUsageSchema]]\n</code></pre> <p>Map the usages by creating a key with the required information for the matching.</p>"},{"location":"reference/agent/#lm_agent.services.license_report","title":"lm_agent.services.license_report","text":"<p>Invoke license stat tools to build a view of license token counts.</p>"},{"location":"reference/agent/#lm_agent.services.license_report.get_local_license_configurations","title":"get_local_license_configurations","text":"<pre><code>get_local_license_configurations(license_configurations: typing.List[ConfigurationSchema], local_licenses: typing.List[str]) -&gt; typing.List[ConfigurationSchema]\n</code></pre> <p>Return the license configurations from the backend that are configured on the cluster.</p>"},{"location":"reference/agent/#lm_agent.services.license_report.report","title":"report  <code>async</code>","text":"<pre><code>report() -&gt; typing.List[LicenseReportItem]\n</code></pre> <p>Get stat counts using a license stat tool.</p> <p>This function iterates over the available license_servers and associated features configured via LICENSE_SERVER_FEATURES and generates a report by requesting license information from the license_server_type.</p> <p>The return from the license server is used to reconcile license-manager's view of what features are available with what actually exists in the license server database.</p>"},{"location":"reference/agent/#lm_agent.services.license_report.update_features","title":"update_features  <code>async</code>","text":"<pre><code>update_features() -&gt; typing.List[LicenseReportItem]\n</code></pre> <p>Send the license data collected from the cluster to the backend.</p>"},{"location":"reference/agent/#lm_agent.services.reconciliation","title":"lm_agent.services.reconciliation","text":"<p>Reconciliation functionality live here.</p>"},{"location":"reference/agent/#lm_agent.services.reconciliation.reconcile","title":"reconcile  <code>async</code>","text":"<pre><code>reconcile()\n</code></pre> <p>Generate the report and reconcile the license feature token usage.</p>"},{"location":"reference/agent/#license-server-backend-utils","title":"License Server Backend Utils","text":""},{"location":"reference/agent/#lm_agent.backend_utils.utils","title":"lm_agent.backend_utils.utils","text":"<p>Provide utilities that communicate with the backend.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.AsyncBackendClient","title":"AsyncBackendClient","text":"<p>               Bases: <code>AsyncClient</code></p> <p>Extends the httpx.AsyncClient class with automatic token acquisition for requests. The token is acquired lazily on the first httpx request issued.</p> <p>This client should be used for most agent actions.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.acquire_token","title":"acquire_token","text":"<pre><code>acquire_token() -&gt; str\n</code></pre> <p>Retrieves a token from OIDC based on the app settings.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.check_backend_health","title":"check_backend_health  <code>async</code>","text":"<pre><code>check_backend_health()\n</code></pre> <p>Hit the API's health-check endpoint to make sure the API is available.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.get_all_features_bookings_sum","title":"get_all_features_bookings_sum  <code>async</code>","text":"<pre><code>get_all_features_bookings_sum() -&gt; Dict[str, int]\n</code></pre> <p>Get booking sum for a license's bookings in all clusters.</p> <p>Note: a license can be configured in multiple clusters, having the same name but different configurations.</p> <p>The booking sum is the sum of all bookings for a license in all clusters.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.get_all_features_from_backend","title":"get_all_features_from_backend  <code>async</code>","text":"<pre><code>get_all_features_from_backend() -&gt; List[FeatureSchema]\n</code></pre> <p>Return the job with its bookings for the given job_id in the cluster.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.get_cluster_configs_from_backend","title":"get_cluster_configs_from_backend  <code>async</code>","text":"<pre><code>get_cluster_configs_from_backend() -&gt; List[ConfigurationSchema]\n</code></pre> <p>Get all configs from the backend for the cluster.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.get_cluster_jobs_from_backend","title":"get_cluster_jobs_from_backend  <code>async</code>","text":"<pre><code>get_cluster_jobs_from_backend() -&gt; List[JobSchema]\n</code></pre> <p>Get all jobs for the cluster with its bookings from the backend.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.make_booking_request","title":"make_booking_request  <code>async</code>","text":"<pre><code>make_booking_request(lbr: LicenseBookingRequest) -&gt; bool\n</code></pre> <p>Create a job and its bookings on the backend for each license booked.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.make_feature_update","title":"make_feature_update  <code>async</code>","text":"<pre><code>make_feature_update(features_to_update: List[Dict])\n</code></pre> <p>Update the feature with its current counters.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.remove_booking","title":"remove_booking  <code>async</code>","text":"<pre><code>remove_booking(booking_id: int)\n</code></pre> <p>Remove the booking with the given id.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.remove_job_by_slurm_job_id","title":"remove_job_by_slurm_job_id  <code>async</code>","text":"<pre><code>remove_job_by_slurm_job_id(slurm_job_id: str)\n</code></pre> <p>Remove the job with its bookings for the given slurm_job_id in the cluster.</p> <p>If the job doesn't exist, the request will be ignored.</p>"},{"location":"reference/agent/#lm_agent.backend_utils.utils.report_cluster_status","title":"report_cluster_status  <code>async</code>","text":"<pre><code>report_cluster_status()\n</code></pre> <p>Report the cluster status to the backend.</p>"},{"location":"reference/agent/#lm_agent.models","title":"lm_agent.models","text":""},{"location":"reference/agent/#lm_agent.models.BookingSchema","title":"BookingSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the booking of a feature.</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>job_id</code>                 (<code>int</code>)             </li> <li> <code>feature_id</code>                 (<code>int</code>)             </li> <li> <code>quantity</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.ConfigurationSchema","title":"ConfigurationSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the configuration for a set of features.</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>cluster_client_id</code>                 (<code>str</code>)             </li> <li> <code>features</code>                 (<code>List[FeatureSchema]</code>)             </li> <li> <code>license_servers</code>                 (<code>List[LicenseServerSchema]</code>)             </li> <li> <code>grace_time</code>                 (<code>int</code>)             </li> <li> <code>type</code>                 (<code>LicenseServerType</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.ExtractedBookingSchema","title":"ExtractedBookingSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the booking from a job with the job information extracted.</p> <p>Fields:</p> <ul> <li> <code>booking_id</code>                 (<code>int</code>)             </li> <li> <code>job_id</code>                 (<code>int</code>)             </li> <li> <code>slurm_job_id</code>                 (<code>str</code>)             </li> <li> <code>username</code>                 (<code>str</code>)             </li> <li> <code>lead_host</code>                 (<code>str</code>)             </li> <li> <code>feature_id</code>                 (<code>int</code>)             </li> <li> <code>quantity</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.ExtractedUsageSchema","title":"ExtractedUsageSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representes the usage lines extracted from a feature report.</p> <p>Fields:</p> <ul> <li> <code>feature_id</code>                 (<code>int</code>)             </li> <li> <code>username</code>                 (<code>str</code>)             </li> <li> <code>lead_host</code>                 (<code>str</code>)             </li> <li> <code>quantity</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.FeatureSchema","title":"FeatureSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the features in a feature configuration.</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>product</code>                 (<code>ProductSchema</code>)             </li> <li> <code>config_id</code>                 (<code>int</code>)             </li> <li> <code>reserved</code>                 (<code>int</code>)             </li> <li> <code>total</code>                 (<code>int</code>)             </li> <li> <code>used</code>                 (<code>int</code>)             </li> <li> <code>booked_total</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.JobSchema","title":"JobSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the jobs submitted in a cluster.</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>slurm_job_id</code>                 (<code>str</code>)             </li> <li> <code>cluster_client_id</code>                 (<code>str</code>)             </li> <li> <code>username</code>                 (<code>str</code>)             </li> <li> <code>lead_host</code>                 (<code>str</code>)             </li> <li> <code>bookings</code>                 (<code>List[BookingSchema]</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.LicenseBooking","title":"LicenseBooking  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Structure to represent a license booking.</p> <p>Fields:</p> <ul> <li> <code>product_feature</code>                 (<code>str</code>)             </li> <li> <code>quantity</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.LicenseBookingRequest","title":"LicenseBookingRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Structure to represent a list of license bookings.</p> <p>Fields:</p> <ul> <li> <code>slurm_job_id</code>                 (<code>str</code>)             </li> <li> <code>username</code>                 (<code>str</code>)             </li> <li> <code>lead_host</code>                 (<code>str</code>)             </li> <li> <code>bookings</code>                 (<code>List[LicenseBooking]</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.LicenseReportItem","title":"LicenseReportItem  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An item in a LicenseReport, a count of tokens for one product/feature.</p> <p>Fields:</p> <ul> <li> <code>feature_id</code>                 (<code>int</code>)             </li> <li> <code>product_feature</code>                 (<code>str</code>)             </li> <li> <code>used</code>                 (<code>int</code>)             </li> <li> <code>total</code>                 (<code>int</code>)             </li> <li> <code>uses</code>                 (<code>List[LicenseUsesItem]</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.LicenseServerSchema","title":"LicenseServerSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>License server response from the database.</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>config_id</code>                 (<code>int</code>)             </li> <li> <code>host</code>                 (<code>str</code>)             </li> <li> <code>port</code>                 (<code>PositiveInt</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.LicenseUsesItem","title":"LicenseUsesItem  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A list of usage information for a license.</p> <p>Fields:</p> <ul> <li> <code>username</code>                 (<code>str</code>)             </li> <li> <code>lead_host</code>                 (<code>str</code>)             </li> <li> <code>booked</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.ParsedFeatureItem","title":"ParsedFeatureItem  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A report of the parsed license server output.</p> <p>Fields:</p> <ul> <li> <code>feature</code>                 (<code>str</code>)             </li> <li> <code>total</code>                 (<code>int</code>)             </li> <li> <code>used</code>                 (<code>int</code>)             </li> <li> <code>uses</code>                 (<code>List[LicenseUsesItem]</code>)             </li> </ul>"},{"location":"reference/agent/#lm_agent.models.ProductSchema","title":"ProductSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a feature's product.</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>name</code>                 (<code>str</code>)             </li> </ul>"},{"location":"reference/api/","title":"License Manager API Reference","text":""},{"location":"reference/api/#configuration-routes","title":"Configuration Routes","text":""},{"location":"reference/api/#lm_api.api.routes.configurations","title":"lm_api.api.routes.configurations","text":""},{"location":"reference/api/#lm_api.api.routes.configurations.create_configuration","title":"create_configuration  <code>async</code>","text":"<pre><code>create_configuration(configuration: ConfigurationCompleteCreateSchema = Body(..., description='Configuration to be created'), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.CONFIG_CREATE)))\n</code></pre> <p>Create a new configuration.</p> <p>The features for the configuration will be specified in the request body. If the feature's product doesn't exist, it will be created.</p>"},{"location":"reference/api/#lm_api.api.routes.configurations.delete_configuration","title":"delete_configuration  <code>async</code>","text":"<pre><code>delete_configuration(configuration_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.CONFIG_DELETE)))\n</code></pre> <p>Delete a configuration from the database.</p> <p>This will also delete the features and license servers associated.</p>"},{"location":"reference/api/#lm_api.api.routes.configurations.read_all_configurations","title":"read_all_configurations  <code>async</code>","text":"<pre><code>read_all_configurations(search: Optional[str] = Query(None), sort_field: Optional[str] = Query(None), sort_ascending: bool = Query(True), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.CONFIG_READ, commit=False)))\n</code></pre> <p>Return all configurations with the associated license servers and features.</p>"},{"location":"reference/api/#lm_api.api.routes.configurations.read_configuration","title":"read_configuration  <code>async</code>","text":"<pre><code>read_configuration(configuration_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.CONFIG_READ, commit=False)))\n</code></pre> <p>Return a configuration with the associated license severs and features with a given id.</p>"},{"location":"reference/api/#lm_api.api.routes.configurations.read_configurations_by_client_id","title":"read_configurations_by_client_id  <code>async</code>","text":"<pre><code>read_configurations_by_client_id(secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.CONFIG_READ, commit=False)))\n</code></pre> <p>Return the configurations with the specified client_id.</p>"},{"location":"reference/api/#lm_api.api.routes.configurations.update_configuration","title":"update_configuration  <code>async</code>","text":"<pre><code>update_configuration(configuration_id: int, configuration_update: ConfigurationCompleteUpdateSchema, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.CONFIG_UPDATE)))\n</code></pre> <p>Update a configuration in the database.</p> <p>If there are features in the payload, they'll be updated if they have an id, or they will be created if the id is None.</p> <p>If there are license servers in the payload, they'll updated if they have an id, or they will be created if the id is None.</p> <p>All resources related to the configuration that aren't present in the payload will be deleted.</p>"},{"location":"reference/api/#configuration-schemas","title":"Configuration Schemas","text":""},{"location":"reference/api/#lm_api.api.schemas.configuration","title":"lm_api.api.schemas.configuration","text":"<p>Configuration schemas for the License Manager API.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteCreateSchema","title":"ConfigurationCompleteCreateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCreateSchema</code></p> <p>Represents the data to create a complete configuration.</p> <p>Includes the features and the license servers.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>cluster_client_id</code>                 (<code>str</code>)             </li> <li> <code>grace_time</code>                 (<code>int</code>)             </li> <li> <code>type</code>                 (<code>LicenseServerType</code>)             </li> <li> <code>features</code>                 (<code>List[FeatureWithoutConfigIdCreateSchema]</code>)             </li> <li> <code>license_servers</code>                 (<code>List[LicenseServerWithoutConfigIdCreateSchema]</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteCreateSchema.cluster_client_id","title":"cluster_client_id  <code>pydantic-field</code>","text":"<pre><code>cluster_client_id: str\n</code></pre> <p>The client ID of the cluster that will use this configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteCreateSchema.features","title":"features  <code>pydantic-field</code>","text":"<pre><code>features: List[FeatureWithoutConfigIdCreateSchema]\n</code></pre> <p>The features of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteCreateSchema.grace_time","title":"grace_time  <code>pydantic-field</code>","text":"<pre><code>grace_time: int = 60\n</code></pre> <p>The grace time in seconds for the license's bookings to be retained.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteCreateSchema.license_servers","title":"license_servers  <code>pydantic-field</code>","text":"<pre><code>license_servers: List[LicenseServerWithoutConfigIdCreateSchema]\n</code></pre> <p>The license servers of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteCreateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteCreateSchema.type","title":"type  <code>pydantic-field</code>","text":"<pre><code>type: LicenseServerType\n</code></pre> <p>The type of license server that provides the license.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteUpdateSchema","title":"ConfigurationCompleteUpdateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseUpdateSchema</code></p> <p>Represents the data to update a complete configuration.</p> <p>Includes the features and the license servers.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>Optional[str]</code>)             </li> <li> <code>cluster_client_id</code>                 (<code>Optional[str]</code>)             </li> <li> <code>grace_time</code>                 (<code>Optional[int]</code>)             </li> <li> <code>type</code>                 (<code>Optional[LicenseServerType]</code>)             </li> <li> <code>features</code>                 (<code>Optional[List[FeatureWithOptionalIdUpdateSchema]]</code>)             </li> <li> <code>license_servers</code>                 (<code>Optional[List[LicenseServerWithOptionalIdUpdateSchema]]</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteUpdateSchema.cluster_client_id","title":"cluster_client_id  <code>pydantic-field</code>","text":"<pre><code>cluster_client_id: Optional[str] = None\n</code></pre> <p>The client ID of the cluster that will use this configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteUpdateSchema.features","title":"features  <code>pydantic-field</code>","text":"<pre><code>features: Optional[List[FeatureWithOptionalIdUpdateSchema]] = None\n</code></pre> <p>The features of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteUpdateSchema.grace_time","title":"grace_time  <code>pydantic-field</code>","text":"<pre><code>grace_time: Optional[int] = None\n</code></pre> <p>The grace time in seconds for the license's bookings to be retained.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteUpdateSchema.license_servers","title":"license_servers  <code>pydantic-field</code>","text":"<pre><code>license_servers: Optional[List[LicenseServerWithOptionalIdUpdateSchema]] = None\n</code></pre> <p>The license servers of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteUpdateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre> <p>The name of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCompleteUpdateSchema.type","title":"type  <code>pydantic-field</code>","text":"<pre><code>type: Optional[LicenseServerType] = None\n</code></pre> <p>The type of license server that provides the license.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCreateSchema","title":"ConfigurationCreateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCreateSchema</code></p> <p>Represents the configuration for a set of features.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>cluster_client_id</code>                 (<code>str</code>)             </li> <li> <code>grace_time</code>                 (<code>int</code>)             </li> <li> <code>type</code>                 (<code>LicenseServerType</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCreateSchema.cluster_client_id","title":"cluster_client_id  <code>pydantic-field</code>","text":"<pre><code>cluster_client_id: str\n</code></pre> <p>The client ID of the cluster that will use this configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCreateSchema.grace_time","title":"grace_time  <code>pydantic-field</code>","text":"<pre><code>grace_time: int = 60\n</code></pre> <p>The grace time in seconds for the license's bookings to be retained.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCreateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationCreateSchema.type","title":"type  <code>pydantic-field</code>","text":"<pre><code>type: LicenseServerType\n</code></pre> <p>The type of license server that provides the license.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationSchema","title":"ConfigurationSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the configuration for a set of features.</p> <p>Config:</p> <ul> <li><code>from_attributes</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>cluster_client_id</code>                 (<code>str</code>)             </li> <li> <code>features</code>                 (<code>List[FeatureSchema]</code>)             </li> <li> <code>license_servers</code>                 (<code>List[LicenseServerSchema]</code>)             </li> <li> <code>grace_time</code>                 (<code>PositiveInt</code>)             </li> <li> <code>type</code>                 (<code>LicenseServerType</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationSchema.cluster_client_id","title":"cluster_client_id  <code>pydantic-field</code>","text":"<pre><code>cluster_client_id: str\n</code></pre> <p>The client ID of the cluster that will use this configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationSchema.features","title":"features  <code>pydantic-field</code>","text":"<pre><code>features: List[FeatureSchema]\n</code></pre> <p>The features of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationSchema.grace_time","title":"grace_time  <code>pydantic-field</code>","text":"<pre><code>grace_time: PositiveInt\n</code></pre> <p>The grace time in seconds for the license's bookings to be retained.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationSchema.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id: int\n</code></pre> <p>The ID of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationSchema.license_servers","title":"license_servers  <code>pydantic-field</code>","text":"<pre><code>license_servers: List[LicenseServerSchema]\n</code></pre> <p>The license servers of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationSchema.type","title":"type  <code>pydantic-field</code>","text":"<pre><code>type: LicenseServerType\n</code></pre> <p>The type of license server that provides the license.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationUpdateSchema","title":"ConfigurationUpdateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseUpdateSchema</code></p> <p>Represents the data for a configuration update.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>Optional[str]</code>)             </li> <li> <code>cluster_client_id</code>                 (<code>Optional[str]</code>)             </li> <li> <code>grace_time</code>                 (<code>Optional[int]</code>)             </li> <li> <code>type</code>                 (<code>Optional[LicenseServerType]</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationUpdateSchema.cluster_client_id","title":"cluster_client_id  <code>pydantic-field</code>","text":"<pre><code>cluster_client_id: Optional[str] = None\n</code></pre> <p>The client ID of the cluster that will use this configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationUpdateSchema.grace_time","title":"grace_time  <code>pydantic-field</code>","text":"<pre><code>grace_time: Optional[int] = None\n</code></pre> <p>The grace time in seconds for the license's bookings to be retained.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationUpdateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre> <p>The name of the configuration.</p>"},{"location":"reference/api/#lm_api.api.schemas.configuration.ConfigurationUpdateSchema.type","title":"type  <code>pydantic-field</code>","text":"<pre><code>type: Optional[LicenseServerType] = None\n</code></pre> <p>The type of license server that provides the license.</p>"},{"location":"reference/api/#license-servers-routes","title":"License Servers Routes","text":""},{"location":"reference/api/#lm_api.api.routes.license_servers","title":"lm_api.api.routes.license_servers","text":""},{"location":"reference/api/#lm_api.api.routes.license_servers.create_license_server","title":"create_license_server  <code>async</code>","text":"<pre><code>create_license_server(license_server: LicenseServerCreateSchema = Body(..., description='License server to be created'), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.LICENSE_SERVER_CREATE)))\n</code></pre> <p>Create a new license server.</p>"},{"location":"reference/api/#lm_api.api.routes.license_servers.delete_license_server","title":"delete_license_server  <code>async</code>","text":"<pre><code>delete_license_server(license_server_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.LICENSE_SERVER_DELETE)))\n</code></pre> <p>Delete a license server from the database.</p>"},{"location":"reference/api/#lm_api.api.routes.license_servers.get_license_server_types","title":"get_license_server_types  <code>async</code>","text":"<pre><code>get_license_server_types(secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.LICENSE_SERVER_READ, commit=False)))\n</code></pre> <p>Return a list of the available license server types.</p>"},{"location":"reference/api/#lm_api.api.routes.license_servers.read_all_license_servers","title":"read_all_license_servers  <code>async</code>","text":"<pre><code>read_all_license_servers(search: Optional[str] = Query(None), sort_field: Optional[str] = Query(None), sort_ascending: bool = Query(True), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.LICENSE_SERVER_READ, commit=False)))\n</code></pre> <p>Return all license servers.</p>"},{"location":"reference/api/#lm_api.api.routes.license_servers.read_license_server","title":"read_license_server  <code>async</code>","text":"<pre><code>read_license_server(license_server_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.LICENSE_SERVER_READ, commit=False)))\n</code></pre> <p>Return a license server with the given id.</p>"},{"location":"reference/api/#lm_api.api.routes.license_servers.update_license_server","title":"update_license_server  <code>async</code>","text":"<pre><code>update_license_server(license_server_id: int, license_server_update: LicenseServerUpdateSchema, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.LICENSE_SERVER_UPDATE)))\n</code></pre> <p>Update a license server in the database.</p>"},{"location":"reference/api/#license-servers-schemas","title":"License Servers Schemas","text":""},{"location":"reference/api/#lm_api.api.schemas.license_server","title":"lm_api.api.schemas.license_server","text":"<p>License Server schemas for the License Manager API.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerCreateSchema","title":"LicenseServerCreateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCreateSchema</code></p> <p>License server to be created in the database.</p> <p>Fields:</p> <ul> <li> <code>config_id</code>                 (<code>int</code>)             </li> <li> <code>host</code>                 (<code>str</code>)             </li> <li> <code>port</code>                 (<code>PositiveInt</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>validate_host</code>                 \u2192                   <code>host</code> </li> <li> <code>validate_port</code>                 \u2192                   <code>port</code> </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerCreateSchema.config_id","title":"config_id  <code>pydantic-field</code>","text":"<pre><code>config_id: int\n</code></pre> <p>The ID of the configuration that the license server belongs to.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerCreateSchema.host","title":"host  <code>pydantic-field</code>","text":"<pre><code>host: str\n</code></pre> <p>The host of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerCreateSchema.port","title":"port  <code>pydantic-field</code>","text":"<pre><code>port: PositiveInt\n</code></pre> <p>The port of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerSchema","title":"LicenseServerSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>License server response from the database.</p> <p>Config:</p> <ul> <li><code>from_attributes</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>config_id</code>                 (<code>int</code>)             </li> <li> <code>host</code>                 (<code>str</code>)             </li> <li> <code>port</code>                 (<code>PositiveInt</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerSchema.config_id","title":"config_id  <code>pydantic-field</code>","text":"<pre><code>config_id: int\n</code></pre> <p>The ID of the configuration that the license server belongs to.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerSchema.host","title":"host  <code>pydantic-field</code>","text":"<pre><code>host: str\n</code></pre> <p>The host of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerSchema.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id: int\n</code></pre> <p>The ID of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerSchema.port","title":"port  <code>pydantic-field</code>","text":"<pre><code>port: PositiveInt\n</code></pre> <p>The port of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerUpdateSchema","title":"LicenseServerUpdateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseUpdateSchema</code></p> <p>License server to be updated in the database.</p> <p>Fields:</p> <ul> <li> <code>config_id</code>                 (<code>Optional[int]</code>)             </li> <li> <code>host</code>                 (<code>Optional[str]</code>)             </li> <li> <code>port</code>                 (<code>Optional[PositiveInt]</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>validate_host</code>                 \u2192                   <code>host</code> </li> <li> <code>validate_port</code>                 \u2192                   <code>port</code> </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerUpdateSchema.config_id","title":"config_id  <code>pydantic-field</code>","text":"<pre><code>config_id: Optional[int] = None\n</code></pre> <p>The ID of the configuration that the license server belongs to.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerUpdateSchema.host","title":"host  <code>pydantic-field</code>","text":"<pre><code>host: Optional[str] = None\n</code></pre> <p>The host of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerUpdateSchema.port","title":"port  <code>pydantic-field</code>","text":"<pre><code>port: Optional[PositiveInt] = None\n</code></pre> <p>The port of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerWithOptionalIdUpdateSchema","title":"LicenseServerWithOptionalIdUpdateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseUpdateSchema</code></p> <p>License server to be updated in the database.</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>Optional[int]</code>)             </li> <li> <code>host</code>                 (<code>Optional[str]</code>)             </li> <li> <code>port</code>                 (<code>Optional[PositiveInt]</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>validate_host</code>                 \u2192                   <code>host</code> </li> <li> <code>validate_port</code>                 \u2192                   <code>port</code> </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerWithOptionalIdUpdateSchema.host","title":"host  <code>pydantic-field</code>","text":"<pre><code>host: Optional[str] = None\n</code></pre> <p>The host of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerWithOptionalIdUpdateSchema.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id: Optional[int] = None\n</code></pre> <p>The ID of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerWithOptionalIdUpdateSchema.port","title":"port  <code>pydantic-field</code>","text":"<pre><code>port: Optional[PositiveInt] = None\n</code></pre> <p>The port of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerWithoutConfigIdCreateSchema","title":"LicenseServerWithoutConfigIdCreateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCreateSchema</code></p> <p>License server to be created by configurations endpoint.</p> <p>The config_id will be handled in the endpoint.</p> <p>Fields:</p> <ul> <li> <code>host</code>                 (<code>str</code>)             </li> <li> <code>port</code>                 (<code>PositiveInt</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>validate_host</code>                 \u2192                   <code>host</code> </li> <li> <code>validate_port</code>                 \u2192                   <code>port</code> </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerWithoutConfigIdCreateSchema.host","title":"host  <code>pydantic-field</code>","text":"<pre><code>host: str\n</code></pre> <p>The host of the license server.</p>"},{"location":"reference/api/#lm_api.api.schemas.license_server.LicenseServerWithoutConfigIdCreateSchema.port","title":"port  <code>pydantic-field</code>","text":"<pre><code>port: PositiveInt\n</code></pre> <p>The port of the license server.</p>"},{"location":"reference/api/#products-routes","title":"Products Routes","text":""},{"location":"reference/api/#lm_api.api.routes.products","title":"lm_api.api.routes.products","text":""},{"location":"reference/api/#lm_api.api.routes.products.create_product","title":"create_product  <code>async</code>","text":"<pre><code>create_product(product: ProductCreateSchema = Body(..., description='Product to be created'), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.PRODUCT_CREATE)))\n</code></pre> <p>Create a new product.</p>"},{"location":"reference/api/#lm_api.api.routes.products.delete_product","title":"delete_product  <code>async</code>","text":"<pre><code>delete_product(product_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.PRODUCT_DELETE)))\n</code></pre> <p>Delete a product from the database and associated features.</p>"},{"location":"reference/api/#lm_api.api.routes.products.read_all_products","title":"read_all_products  <code>async</code>","text":"<pre><code>read_all_products(search: Optional[str] = Query(None), sort_field: Optional[str] = Query(None), sort_ascending: bool = Query(True), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.PRODUCT_READ, commit=False)))\n</code></pre> <p>Return all products with associated features.</p>"},{"location":"reference/api/#lm_api.api.routes.products.read_product","title":"read_product  <code>async</code>","text":"<pre><code>read_product(product_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.PRODUCT_READ, commit=False)))\n</code></pre> <p>Return a product with associated features with the given id.</p>"},{"location":"reference/api/#lm_api.api.routes.products.update_product","title":"update_product  <code>async</code>","text":"<pre><code>update_product(product_id: int, product_update: ProductUpdateSchema, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.PRODUCT_UPDATE)))\n</code></pre> <p>Update a product in the database.</p>"},{"location":"reference/api/#products-schemas","title":"Products Schemas","text":""},{"location":"reference/api/#lm_api.api.schemas.product","title":"lm_api.api.schemas.product","text":"<p>Product schemas for the License Manager API.</p>"},{"location":"reference/api/#lm_api.api.schemas.product.ProductCreateSchema","title":"ProductCreateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCreateSchema</code></p> <p>Represents a feature's product.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>str</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.product.ProductCreateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the product.</p>"},{"location":"reference/api/#lm_api.api.schemas.product.ProductSchema","title":"ProductSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a feature's product.</p> <p>Config:</p> <ul> <li><code>from_attributes</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>name</code>                 (<code>str</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.product.ProductSchema.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id: int\n</code></pre> <p>The ID of the product.</p>"},{"location":"reference/api/#lm_api.api.schemas.product.ProductSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the product.</p>"},{"location":"reference/api/#lm_api.api.schemas.product.ProductUpdateSchema","title":"ProductUpdateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseUpdateSchema</code></p> <p>Represents a feature's product.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>Optional[str]</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.product.ProductUpdateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre> <p>The name of the product.</p>"},{"location":"reference/api/#features-routes","title":"Features Routes","text":""},{"location":"reference/api/#lm_api.api.routes.features","title":"lm_api.api.routes.features","text":""},{"location":"reference/api/#lm_api.api.routes.features.bulk_update_feature","title":"bulk_update_feature  <code>async</code>","text":"<pre><code>bulk_update_feature(features: List[FeatureUpdateByNameSchema], secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.FEATURE_UPDATE)))\n</code></pre> <p>Update a list of features in the database using the name of each feature. Since the name is not unique across clusters, the client_id in the token is used to identify the cluster.</p>"},{"location":"reference/api/#lm_api.api.routes.features.create_feature","title":"create_feature  <code>async</code>","text":"<pre><code>create_feature(feature: FeatureCreateSchema = Body(..., description='Feature to be created'), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.FEATURE_CREATE)))\n</code></pre> <p>Create a new feature</p>"},{"location":"reference/api/#lm_api.api.routes.features.delete_feature","title":"delete_feature  <code>async</code>","text":"<pre><code>delete_feature(feature_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.FEATURE_DELETE)))\n</code></pre> <p>Delete a feature from the database.</p>"},{"location":"reference/api/#lm_api.api.routes.features.read_all_features","title":"read_all_features  <code>async</code>","text":"<pre><code>read_all_features(search: Optional[str] = Query(None), sort_field: Optional[str] = Query(None), sort_ascending: bool = Query(True), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.FEATURE_READ, commit=False)))\n</code></pre> <p>Return all features with associated bookings.</p>"},{"location":"reference/api/#lm_api.api.routes.features.read_feature","title":"read_feature  <code>async</code>","text":"<pre><code>read_feature(feature_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.FEATURE_READ, commit=False)))\n</code></pre> <p>Return a feature with associated bookings with the given id.</p>"},{"location":"reference/api/#lm_api.api.routes.features.update_feature","title":"update_feature  <code>async</code>","text":"<pre><code>update_feature(feature_id: int, feature_update: FeatureUpdateSchema, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.FEATURE_UPDATE)))\n</code></pre> <p>Update a feature in the database.</p>"},{"location":"reference/api/#features-schemas","title":"Features Schemas","text":""},{"location":"reference/api/#lm_api.api.schemas.feature","title":"lm_api.api.schemas.feature","text":"<p>Feature schemas for the License Manager API.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureCreateSchema","title":"FeatureCreateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCreateSchema</code></p> <p>Represents the features in a feature configuration.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>product_id</code>                 (<code>int</code>)             </li> <li> <code>config_id</code>                 (<code>int</code>)             </li> <li> <code>reserved</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureCreateSchema.config_id","title":"config_id  <code>pydantic-field</code>","text":"<pre><code>config_id: int\n</code></pre> <p>The ID of the configuration that the feature belongs to.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureCreateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureCreateSchema.product_id","title":"product_id  <code>pydantic-field</code>","text":"<pre><code>product_id: int\n</code></pre> <p>The ID of the product of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureCreateSchema.reserved","title":"reserved  <code>pydantic-field</code>","text":"<pre><code>reserved: int = 0\n</code></pre> <p>The quantity of the feature that is reserved for usage in desktop environments.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureSchema","title":"FeatureSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the features in a feature configuration.</p> <p>Config:</p> <ul> <li><code>from_attributes</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>int</code>)             </li> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>product</code>                 (<code>ProductSchema</code>)             </li> <li> <code>config_id</code>                 (<code>int</code>)             </li> <li> <code>reserved</code>                 (<code>NonNegativeInt</code>)             </li> <li> <code>total</code>                 (<code>NonNegativeInt</code>)             </li> <li> <code>used</code>                 (<code>NonNegativeInt</code>)             </li> <li> <code>booked_total</code>                 (<code>Optional[NonNegativeInt]</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureSchema.booked_total","title":"booked_total  <code>pydantic-field</code>","text":"<pre><code>booked_total: Optional[NonNegativeInt] = 0\n</code></pre> <p>The total quantity of licenses that are booked.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureSchema.config_id","title":"config_id  <code>pydantic-field</code>","text":"<pre><code>config_id: int\n</code></pre> <p>The ID of the configuration that the feature belongs to.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureSchema.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id: int\n</code></pre> <p>The ID of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureSchema.product","title":"product  <code>pydantic-field</code>","text":"<pre><code>product: ProductSchema\n</code></pre> <p>The product of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureSchema.reserved","title":"reserved  <code>pydantic-field</code>","text":"<pre><code>reserved: NonNegativeInt = 0\n</code></pre> <p>The quantity of the feature that is reserved for usage in desktop environments.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureSchema.total","title":"total  <code>pydantic-field</code>","text":"<pre><code>total: NonNegativeInt = 0\n</code></pre> <p>The total quantity of licenses.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureSchema.used","title":"used  <code>pydantic-field</code>","text":"<pre><code>used: NonNegativeInt = 0\n</code></pre> <p>The quantity of the feature that is used.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateByNameSchema","title":"FeatureUpdateByNameSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseUpdateSchema</code></p> <p>Represents the feature usage data that will be updated using the product and feature name as a filter.</p> <p>Fields:</p> <ul> <li> <code>product_name</code>                 (<code>str</code>)             </li> <li> <code>feature_name</code>                 (<code>str</code>)             </li> <li> <code>total</code>                 (<code>int</code>)             </li> <li> <code>used</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateByNameSchema.feature_name","title":"feature_name  <code>pydantic-field</code>","text":"<pre><code>feature_name: str\n</code></pre> <p>The name of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateByNameSchema.product_name","title":"product_name  <code>pydantic-field</code>","text":"<pre><code>product_name: str\n</code></pre> <p>The name of the product.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateByNameSchema.total","title":"total  <code>pydantic-field</code>","text":"<pre><code>total: int = 0\n</code></pre> <p>The total quantity of licenses.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateByNameSchema.used","title":"used  <code>pydantic-field</code>","text":"<pre><code>used: int = 0\n</code></pre> <p>The quantity of the feature that is used.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateSchema","title":"FeatureUpdateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseUpdateSchema</code></p> <p>Represents the features in a feature configuration.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>Optional[str]</code>)             </li> <li> <code>product_id</code>                 (<code>Optional[int]</code>)             </li> <li> <code>config_id</code>                 (<code>Optional[int]</code>)             </li> <li> <code>reserved</code>                 (<code>Optional[int]</code>)             </li> <li> <code>total</code>                 (<code>Optional[int]</code>)             </li> <li> <code>used</code>                 (<code>Optional[int]</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateSchema.config_id","title":"config_id  <code>pydantic-field</code>","text":"<pre><code>config_id: Optional[int] = None\n</code></pre> <p>The ID of the configuration that the feature belongs to.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre> <p>The name of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateSchema.product_id","title":"product_id  <code>pydantic-field</code>","text":"<pre><code>product_id: Optional[int] = None\n</code></pre> <p>The ID of the product of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateSchema.reserved","title":"reserved  <code>pydantic-field</code>","text":"<pre><code>reserved: Optional[int] = None\n</code></pre> <p>The quantity of the feature that is reserved for usage in desktop environments.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateSchema.total","title":"total  <code>pydantic-field</code>","text":"<pre><code>total: Optional[int] = None\n</code></pre> <p>The total quantity of licenses.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureUpdateSchema.used","title":"used  <code>pydantic-field</code>","text":"<pre><code>used: Optional[int] = None\n</code></pre> <p>The quantity of the feature that is used.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureWithOptionalIdUpdateSchema","title":"FeatureWithOptionalIdUpdateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseUpdateSchema</code></p> <p>Feature to be updated in the database.</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>Optional[int]</code>)             </li> <li> <code>name</code>                 (<code>Optional[str]</code>)             </li> <li> <code>product_id</code>                 (<code>Optional[int]</code>)             </li> <li> <code>reserved</code>                 (<code>Optional[int]</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureWithOptionalIdUpdateSchema.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id: Optional[int] = None\n</code></pre> <p>The ID of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureWithOptionalIdUpdateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre> <p>The name of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureWithOptionalIdUpdateSchema.product_id","title":"product_id  <code>pydantic-field</code>","text":"<pre><code>product_id: Optional[int] = None\n</code></pre> <p>The ID of the product of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureWithOptionalIdUpdateSchema.reserved","title":"reserved  <code>pydantic-field</code>","text":"<pre><code>reserved: Optional[int] = None\n</code></pre> <p>The quantity of the feature that is reserved for usage in desktop environments.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureWithoutConfigIdCreateSchema","title":"FeatureWithoutConfigIdCreateSchema  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseCreateSchema</code></p> <p>Represents the features in a feature configuration.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>product_id</code>                 (<code>int</code>)             </li> <li> <code>reserved</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureWithoutConfigIdCreateSchema.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureWithoutConfigIdCreateSchema.product_id","title":"product_id  <code>pydantic-field</code>","text":"<pre><code>product_id: int\n</code></pre> <p>The ID of the product of the feature.</p>"},{"location":"reference/api/#lm_api.api.schemas.feature.FeatureWithoutConfigIdCreateSchema.reserved","title":"reserved  <code>pydantic-field</code>","text":"<pre><code>reserved: int = 0\n</code></pre> <p>The quantity of the feature that is reserved for usage in desktop environments.</p>"},{"location":"reference/api/#jobs-routes","title":"Jobs Routes","text":""},{"location":"reference/api/#lm_api.api.routes.jobs","title":"lm_api.api.routes.jobs","text":""},{"location":"reference/api/#lm_api.api.routes.jobs.create_job","title":"create_job  <code>async</code>","text":"<pre><code>create_job(job: JobWithBookingCreateSchema = Body(..., description='Job to be created'), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.JOB_CREATE)))\n</code></pre> <p>Create a new job.</p>"},{"location":"reference/api/#lm_api.api.routes.jobs.delete_job","title":"delete_job  <code>async</code>","text":"<pre><code>delete_job(job_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.JOB_DELETE)))\n</code></pre> <p>Delete a job from the database and associated bookings.</p>"},{"location":"reference/api/#lm_api.api.routes.jobs.delete_job_by_slurm_id","title":"delete_job_by_slurm_id  <code>async</code>","text":"<pre><code>delete_job_by_slurm_id(slurm_job_id: str, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.JOB_DELETE)))\n</code></pre> <p>Delete a job from the database and associated bookings.</p> <p>Uses the slurm_job_id and the cluster client_id to filter the job.</p> <p>Since the slurm_job_id can be the same across clusters, we need the cluster client_id to validate.</p>"},{"location":"reference/api/#lm_api.api.routes.jobs.read_all_jobs","title":"read_all_jobs  <code>async</code>","text":"<pre><code>read_all_jobs(search: Optional[str] = Query(None), sort_field: Optional[str] = Query(None), sort_ascending: bool = Query(True), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.JOB_READ, commit=False)))\n</code></pre> <p>Return all jobs.</p>"},{"location":"reference/api/#lm_api.api.routes.jobs.read_job","title":"read_job  <code>async</code>","text":"<pre><code>read_job(job_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.JOB_READ, commit=False)))\n</code></pre> <p>Return a job with associated bookings with the given id.</p>"},{"location":"reference/api/#lm_api.api.routes.jobs.read_job_by_slurm_id","title":"read_job_by_slurm_id  <code>async</code>","text":"<pre><code>read_job_by_slurm_id(slurm_job_id: str, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.JOB_READ, commit=False)))\n</code></pre> <p>Read a job from the database and associated bookings.</p> <p>Uses the slurm_job_id and the cluster client_id to filter the job.</p> <p>Since the slurm_job_id can be the same across clusters, we need the cluster client_id to validate.</p>"},{"location":"reference/api/#lm_api.api.routes.jobs.read_jobs_by_client_id","title":"read_jobs_by_client_id  <code>async</code>","text":"<pre><code>read_jobs_by_client_id(secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.JOB_READ, commit=False)))\n</code></pre> <p>Return the jobs with the specified OIDC client_id retrieved from the request.</p>"},{"location":"reference/api/#jobs-schemas","title":"Jobs Schemas","text":""},{"location":"reference/api/#lm_api.api.routes.bookings","title":"lm_api.api.routes.bookings","text":""},{"location":"reference/api/#lm_api.api.routes.bookings.create_booking","title":"create_booking  <code>async</code>","text":"<pre><code>create_booking(booking: BookingCreateSchema = Body(..., description='Booking to be created'), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.BOOKING_CREATE)))\n</code></pre> <p>Create a new booking.</p>"},{"location":"reference/api/#lm_api.api.routes.bookings.delete_booking","title":"delete_booking  <code>async</code>","text":"<pre><code>delete_booking(booking_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.BOOKING_DELETE)))\n</code></pre> <p>Delete a booking from the database.</p>"},{"location":"reference/api/#lm_api.api.routes.bookings.read_all_bookings","title":"read_all_bookings  <code>async</code>","text":"<pre><code>read_all_bookings(sort_field: Optional[str] = Query(None), sort_ascending: bool = Query(True), secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.BOOKING_READ, commit=False)))\n</code></pre> <p>Return all bookings.</p>"},{"location":"reference/api/#lm_api.api.routes.bookings.read_booking","title":"read_booking  <code>async</code>","text":"<pre><code>read_booking(booking_id: int, secure_session: SecureSession = Depends(secure_session(Permissions.ADMIN, Permissions.BOOKING_READ, commit=False)))\n</code></pre> <p>Return a booking with associated bookings with the given id.</p>"},{"location":"reference/cli/","title":"License Manager CLI Reference","text":""},{"location":"reference/cli/#global-commands","title":"Global Commands","text":""},{"location":"reference/cli/#lm_cli.main","title":"lm_cli.main","text":"<p>Entry point for the License Manager CLI App.</p>"},{"location":"reference/cli/#lm_cli.main.login","title":"login","text":"<pre><code>login(ctx: typer.Context)\n</code></pre> <p>Log in to the lm-cli by storing the supplied token argument in the cache.</p>"},{"location":"reference/cli/#lm_cli.main.logout","title":"logout","text":"<pre><code>logout()\n</code></pre> <p>Log out of the lm-cli.</p>"},{"location":"reference/cli/#lm_cli.main.main","title":"main","text":"<pre><code>main(ctx: typer.Context, verbose: bool = typer.Option(False, help='Enable verbose logging to the terminal'), version: bool = typer.Option(False, help='Print the version of lm-cli and exit'))\n</code></pre> <p>Welcome to the License Manager CLI!</p> <p>More information can be shown for each command listed below by running it with the --help option.</p>"},{"location":"reference/cli/#lm_cli.main.show_token","title":"show_token","text":"<pre><code>show_token(plain: bool = typer.Option(False, help='Show the token in plain text.'), refresh: bool = typer.Option(False, help='Show the refresh token instead of the access token.'), show_prefix: bool = typer.Option(False, '--prefix', help=\"Include the 'Bearer' prefix in the output.\"), show_header: bool = typer.Option(False, '--header', help='Show the token as it would appear in a request header.'), decode: bool = typer.Option(False, '--decode', help='Show the content of the decoded access token.'))\n</code></pre> <p>Show the token for the logged in user.</p> <p>Token output is automatically copied to your clipboard.</p>"},{"location":"reference/cli/#configurations","title":"Configurations","text":""},{"location":"reference/cli/#lm_cli.subapps.configurations","title":"lm_cli.subapps.configurations","text":"<p>A <code>typer</code> app that can interact with Configurations data in a cruddy manner.</p>"},{"location":"reference/cli/#lm_cli.subapps.configurations.create","title":"create","text":"<pre><code>create(ctx: typer.Context, name: str = typer.Option(..., help='The name of configuration to create.'), cluster_client_id: str = typer.Option(..., help='The cluster OIDC client_id of the cluster where the configuration is being added.'), grace_time: int = typer.Option(..., help='The grace time for jobs using the license. Must be in seconds.'), license_server_type: LicenseServerType = typer.Option(..., help='The license server type.'))\n</code></pre> <p>Create a new configuration.</p>"},{"location":"reference/cli/#lm_cli.subapps.configurations.delete","title":"delete","text":"<pre><code>delete(ctx: typer.Context, id: int = typer.Option(..., help='The id of the configuration to delete.'))\n</code></pre> <p>Delete an existing configuration.</p>"},{"location":"reference/cli/#lm_cli.subapps.configurations.format_data","title":"format_data","text":"<pre><code>format_data(data)\n</code></pre> <p>Return data in the correct format for printing.</p>"},{"location":"reference/cli/#lm_cli.subapps.configurations.get_one","title":"get_one","text":"<pre><code>get_one(ctx: typer.Context, id: int = typer.Option(int, help='The specific id of the configuration.'))\n</code></pre> <p>Get a single configuration by id.</p>"},{"location":"reference/cli/#lm_cli.subapps.configurations.list_all","title":"list_all","text":"<pre><code>list_all(ctx: typer.Context, search: Optional[str] = typer.Option(None, help='Apply a search term to results.'), sort_order: SortOrder = typer.Option(SortOrder.UNSORTED, help='Specify sort order.'), sort_field: Optional[str] = typer.Option(None, help='The field by which results should be sorted.'))\n</code></pre> <p>Show configuration information.</p>"},{"location":"reference/cli/#license-servers","title":"License Servers","text":""},{"location":"reference/cli/#lm_cli.subapps.license_servers","title":"lm_cli.subapps.license_servers","text":"<p>A <code>typer</code> app that can interact with License Servers data in a cruddy manner.</p>"},{"location":"reference/cli/#lm_cli.subapps.license_servers.create","title":"create","text":"<pre><code>create(ctx: typer.Context, config_id: int = typer.Option(..., help='The config_id of the license server.'), host: str = typer.Option(..., help='The hostname of the license server.'), port: int = typer.Option(..., help='The port of the license server.'))\n</code></pre> <p>Create a new license server.</p>"},{"location":"reference/cli/#lm_cli.subapps.license_servers.delete","title":"delete","text":"<pre><code>delete(ctx: typer.Context, id: int = typer.Option(..., help='The id of the license server to delete.'))\n</code></pre> <p>Delete an existing license server.</p>"},{"location":"reference/cli/#lm_cli.subapps.license_servers.get_one","title":"get_one","text":"<pre><code>get_one(ctx: typer.Context, id: int = typer.Option(int, help='The specific id of the license server.'))\n</code></pre> <p>Get a single license server by id.</p>"},{"location":"reference/cli/#lm_cli.subapps.license_servers.list_all","title":"list_all","text":"<pre><code>list_all(ctx: typer.Context, search: Optional[str] = typer.Option(None, help='Apply a search term to results.'), sort_order: SortOrder = typer.Option(SortOrder.UNSORTED, help='Specify sort order.'), sort_field: Optional[str] = typer.Option(None, help='The field by which results should be sorted.'))\n</code></pre> <p>Show license server information.</p>"},{"location":"reference/cli/#products","title":"Products","text":""},{"location":"reference/cli/#lm_cli.subapps.products","title":"lm_cli.subapps.products","text":"<p>A <code>typer</code> app that can interact with Products data in a cruddy manner.</p>"},{"location":"reference/cli/#lm_cli.subapps.products.create","title":"create","text":"<pre><code>create(ctx: typer.Context, name: str = typer.Option(..., help='The name of product to create. Must match the product name in the license.'))\n</code></pre> <p>Create a new product.</p>"},{"location":"reference/cli/#lm_cli.subapps.products.delete","title":"delete","text":"<pre><code>delete(ctx: typer.Context, id: int = typer.Option(..., help='The id of the product to delete.'))\n</code></pre> <p>Delete an existing product.</p>"},{"location":"reference/cli/#lm_cli.subapps.products.get_one","title":"get_one","text":"<pre><code>get_one(ctx: typer.Context, id: int = typer.Option(int, help='The specific id of the product.'))\n</code></pre> <p>Get a single product by id.</p>"},{"location":"reference/cli/#lm_cli.subapps.products.list_all","title":"list_all","text":"<pre><code>list_all(ctx: typer.Context, search: Optional[str] = typer.Option(None, help='Apply a search term to results.'), sort_order: SortOrder = typer.Option(SortOrder.UNSORTED, help='Specify sort order.'), sort_field: Optional[str] = typer.Option(None, help='The field by which results should be sorted.'))\n</code></pre> <p>Show product information.</p>"},{"location":"reference/cli/#features","title":"Features","text":""},{"location":"reference/cli/#lm_cli.subapps.features","title":"lm_cli.subapps.features","text":"<p>A <code>typer</code> app that can interact with Features data in a cruddy manner.</p>"},{"location":"reference/cli/#lm_cli.subapps.features.create","title":"create","text":"<pre><code>create(ctx: typer.Context, name: str = typer.Option(..., help='The name of feature to create. Must match the feature name in the license.'), product_id: int = typer.Option(..., help='The product_id of the feature.'), config_id: int = typer.Option(..., help='The config_id of the feature.'), reserved: int = typer.Option(..., help='How many licenses should be reserved for usage in desktop enviroments.'))\n</code></pre> <p>Create a new feature.</p>"},{"location":"reference/cli/#lm_cli.subapps.features.delete","title":"delete","text":"<pre><code>delete(ctx: typer.Context, id: int = typer.Option(..., help='The id of the feature to delete.'))\n</code></pre> <p>Delete an existing feature.</p>"},{"location":"reference/cli/#lm_cli.subapps.features.format_data","title":"format_data","text":"<pre><code>format_data(feature_data)\n</code></pre> <p>Return data in the correct format for printing.</p>"},{"location":"reference/cli/#lm_cli.subapps.features.get_one","title":"get_one","text":"<pre><code>get_one(ctx: typer.Context, id: int = typer.Option(int, help='The specific id of the feature.'))\n</code></pre> <p>Get a single feature by id.</p>"},{"location":"reference/cli/#lm_cli.subapps.features.list_all","title":"list_all","text":"<pre><code>list_all(ctx: typer.Context, search: Optional[str] = typer.Option(None, help='Apply a search term to results.'), sort_order: SortOrder = typer.Option(SortOrder.UNSORTED, help='Specify sort order.'), sort_field: Optional[str] = typer.Option(None, help='The field by which results should be sorted.'))\n</code></pre> <p>Show feature information.</p>"},{"location":"reference/cli/#jobs","title":"Jobs","text":""},{"location":"reference/cli/#lm_cli.subapps.jobs","title":"lm_cli.subapps.jobs","text":"<p>A <code>typer</code> app that can interact with Jobs endpoint to list data.</p>"},{"location":"reference/cli/#lm_cli.subapps.jobs.list_all","title":"list_all","text":"<pre><code>list_all(ctx: typer.Context, search: Optional[str] = typer.Option(None, help='Apply a search term to results.'), sort_order: SortOrder = typer.Option(SortOrder.UNSORTED, help='Specify sort order.'), sort_field: Optional[str] = typer.Option(None, help='The field by which results should be sorted.'))\n</code></pre> <p>Show job information.</p>"},{"location":"reference/cli/#bookings","title":"Bookings","text":""},{"location":"reference/cli/#lm_cli.subapps.bookings","title":"lm_cli.subapps.bookings","text":"<p>A <code>typer</code> app that can interact with Bookings endpoint to list data.</p>"},{"location":"reference/cli/#lm_cli.subapps.bookings.list_all","title":"list_all","text":"<pre><code>list_all(ctx: typer.Context, search: Optional[str] = typer.Option(None, help='Apply a search term to results.'), sort_order: SortOrder = typer.Option(SortOrder.UNSORTED, help='Specify sort order.'), sort_field: Optional[str] = typer.Option(None, help='The field by which results should be sorted.'))\n</code></pre> <p>Show booking information.</p>"}]}